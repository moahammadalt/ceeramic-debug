{"version":3,"file":"lib.mjs","sources":["../src/index.ts"],"sourcesContent":["/**\n * ```sh\n * npm install @glazed/tile-loader\n * ```\n *\n * @module tile-loader\n */\n\n// Polyfill setImmediate for browsers not supporting it - see https://github.com/graphql/dataloader/issues/249\nimport 'setimmediate'\nimport type { CeramicApi, CreateOpts, GenesisCommit, MultiQuery } from '@ceramicnetwork/common'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\nimport type { TileMetadataArgs } from '@ceramicnetwork/stream-tile'\nimport { CommitID, StreamID, StreamRef } from '@ceramicnetwork/streamid'\nimport DataLoader from 'dataloader'\n\n/**\n * Omit `path` and `atTime` from [MultiQuery](https://developers.ceramic.network/reference/typescript/interfaces/_ceramicnetwork_common.multiquery-1.html) as the cache needs to be deterministic based on the ID.\n */\nexport type TileQuery = Omit<MultiQuery, 'paths' | 'atTime'>\n\nexport type TileKey = CommitID | StreamID | TileQuery | string\n\n// Implements CacheMap from dataloader, copied here to generate docs\nexport type TileCache = {\n  /**\n   * get a Promise of a TileDocument by its stream ID\n   */\n  get(id: string): Promise<TileDocument> | void\n  /**\n   * set a Promise of a TileDocument by its stream ID\n   */\n  set(id: string, value: Promise<TileDocument>): any\n  /**\n   * remove a specific entry from the cache\n   */\n  delete(id: string): any\n  /**\n   * remove all entries from the cache\n   */\n  clear(): any\n}\n\nexport type TileLoaderParams = {\n  /**\n   * A Ceramic client instance\n   */\n  ceramic: CeramicApi\n  /**\n   * A supported cache implementation, `true` to use the default implementation or `false` to disable the cache (default)\n   */\n  cache?: TileCache | boolean\n}\n\n/** @internal */\nexport function keyToQuery(key: TileKey): TileQuery {\n  return typeof key === 'string' || CommitID.isInstance(key) || StreamID.isInstance(key)\n    ? { streamId: key }\n    : { streamId: key.streamId, genesis: key.genesis }\n}\n\n/** @internal */\nexport function keyToString(key: TileKey): string {\n  if (typeof key === 'string') {\n    // Convert possible URL input to string representation to match returned keys format\n    return StreamRef.from(key).toString()\n  }\n  if (CommitID.isInstance(key) || StreamID.isInstance(key)) {\n    return key.toString()\n  }\n  return key.streamId.toString()\n}\n\n/**\n * Create a {@linkcode TileQuery} for a determinitic TileDocument based on its metadata.\n */\nexport async function getDeterministicQuery(metadata: TileMetadataArgs): Promise<TileQuery> {\n  const genesis = (await TileDocument.makeGenesis({} as any, null, {\n    ...metadata,\n    deterministic: true,\n  })) as GenesisCommit\n  const streamId = await StreamID.fromGenesis('tile', genesis)\n  return { genesis, streamId }\n}\n\n/**\n * A TileLoader extends [DataLoader](https://github.com/graphql/dataloader) to provide batching and caching functionalities for loading TileDocument streams.\n */\nexport class TileLoader extends DataLoader<TileKey, TileDocument> {\n  #ceramic: CeramicApi\n  #useCache: boolean\n\n  constructor(params: TileLoaderParams) {\n    super(\n      async (keys) => {\n        if (!params.cache) {\n          // Disable cache but keep batching behavior - from https://github.com/graphql/dataloader#disabling-cache\n          this.clearAll()\n        }\n        const results = await params.ceramic.multiQuery(keys.map(keyToQuery))\n        return keys.map((key) => {\n          const id = keyToString(key)\n          const doc = results[id]\n          return doc ? (doc as TileDocument) : new Error(`Failed to load stream: ${id}`)\n        })\n      },\n      {\n        cache: true, // Cache needs to be enabled for batching\n        cacheKeyFn: keyToString,\n        cacheMap:\n          params.cache != null && typeof params.cache !== 'boolean' ? params.cache : undefined,\n      }\n    )\n\n    this.#ceramic = params.ceramic\n    this.#useCache = !!params.cache\n  }\n\n  /**\n   * Add a TileDocument to the local cache if enabled.\n   */\n  cache(stream: TileDocument): boolean {\n    if (!this.#useCache) {\n      return false\n    }\n\n    const id = stream.id.toString()\n    this.clear(id).prime(id, stream)\n    return true\n  }\n\n  /**\n   * Create a new TileDocument and add it to the cache if enabled.\n   */\n  async create<T extends Record<string, any> = Record<string, any>>(\n    content: T,\n    metadata?: TileMetadataArgs,\n    options?: CreateOpts\n  ): Promise<TileDocument<T>> {\n    const stream = await TileDocument.create<T>(this.#ceramic, content, metadata, options)\n    this.cache(stream)\n    return stream\n  }\n\n  /**\n   * Create or load a deterministic TileDocument based on its metadata.\n   */\n  async deterministic<T extends Record<string, any> = Record<string, any>>(\n    metadata: TileMetadataArgs,\n    options?: CreateOpts\n  ): Promise<TileDocument<T | null | undefined>> {\n    const query = await getDeterministicQuery(metadata)\n    try {\n      return (await super.load(query)) as TileDocument<T | null | undefined>\n    } catch (err) {\n      const stream = await TileDocument.createFromGenesis<T>(\n        this.#ceramic,\n        query.genesis as GenesisCommit,\n        options\n      )\n      this.cache(stream)\n      return stream\n    }\n  }\n\n  /**\n   * Load a TileDocument from the cache (if enabled) or remotely.\n   */\n  async load<T extends Record<string, any> = Record<string, any>>(\n    key: TileKey\n  ): Promise<TileDocument<T>> {\n    return (await super.load(key)) as TileDocument<T>\n  }\n}\n"],"names":[],"mappings":"yhBAuD2B,EAAyB,OAC3C,OAAO,IAAQ,UAAY,EAAS,WAAW,IAAQ,EAAS,WAAW,GAC9E,CAAE,SAAU,GACZ,CAAE,SAAU,EAAI,SAAU,QAAS,EAAI,oBAIjB,EAAsB,OAC5C,OAAO,IAAQ,SAEV,EAAU,KAAK,GAAK,WAEzB,EAAS,WAAW,IAAQ,EAAS,WAAW,GAC3C,EAAI,WAEN,EAAI,SAAS,4BAMsB,EAAgD,MACpF,GAAW,KAAM,GAAa,YAAY,GAAW,KAAM,IAC5D,EACH,cAAe,KAEX,EAAW,KAAM,GAAS,YAAY,OAAQ,SAC7C,CAAE,UAAS,2BAMY,EAAkC,CAIhE,YAAY,EAA0B,OAElC,KAAO,IAAS,CACT,EAAO,YAEL,gBAED,GAAU,KAAM,GAAO,QAAQ,WAAW,EAAK,IAAI,UAClD,GAAK,IAAI,AAAC,GAAQ,MACjB,GAAK,EAAY,GACjB,EAAM,EAAQ,SACb,IAA8B,GAAI,OAAM,0BAA0B,QAG7E,CACE,MAAO,GACP,WAAY,EACZ,SACE,EAAO,OAAS,MAAQ,MAAO,GAAO,OAAU,UAAY,EAAO,MAAQ,kDAI5E,EAAW,EAAO,gBAClB,EAAY,CAAC,CAAC,EAAO,OAM5B,MAAM,EAA+B,IAC/B,CAAC,OAAK,SACD,QAGH,GAAK,EAAO,GAAG,uBAChB,MAAM,GAAI,MAAM,EAAI,GAClB,QAMH,QACJ,EACA,EACA,EAC0B,MACpB,GAAS,KAAM,GAAa,OAAU,OAAK,GAAU,EAAS,EAAU,eACzE,MAAM,GACJ,OAMH,eACJ,EACA,EAC6C,MACvC,GAAQ,KAAM,GAAsB,MACtC,OACM,MAAM,OAAM,KAAK,cAEnB,GAAS,KAAM,GAAa,kBAChC,OAAK,GACL,EAAM,QACN,eAEG,MAAM,GACJ,QAOL,MACJ,EAC0B,OAClB,MAAM,OAAM,KAAK,IAlF3B,cACA"}