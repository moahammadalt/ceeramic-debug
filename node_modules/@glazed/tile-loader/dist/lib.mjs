import"setimmediate";import{TileDocument as o}from"@ceramicnetwork/stream-tile";import{CommitID as l,StreamID as d,StreamRef as I}from"@ceramicnetwork/streamid";import _ from"dataloader";var f=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},u=(e,t,r)=>(f(e,t,"read from private field"),r?r.call(e):t.get(e)),p=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},w=(e,t,r,a)=>(f(e,t,"write to private field"),a?a.call(e,r):t.set(e,r),r),c,s;function g(e){return typeof e=="string"||l.isInstance(e)||d.isInstance(e)?{streamId:e}:{streamId:e.streamId,genesis:e.genesis}}function h(e){return typeof e=="string"?I.from(e).toString():l.isInstance(e)||d.isInstance(e)?e.toString():e.streamId.toString()}async function v(e){const t=await o.makeGenesis({},null,{...e,deterministic:!0}),r=await d.fromGenesis("tile",t);return{genesis:t,streamId:r}}class S extends _{constructor(t){super(async r=>{t.cache||this.clearAll();const a=await t.ceramic.multiQuery(r.map(g));return r.map(i=>{const n=h(i),m=a[n];return m||new Error(`Failed to load stream: ${n}`)})},{cache:!0,cacheKeyFn:h,cacheMap:t.cache!=null&&typeof t.cache!="boolean"?t.cache:void 0});p(this,c,void 0),p(this,s,void 0),w(this,c,t.ceramic),w(this,s,!!t.cache)}cache(t){if(!u(this,s))return!1;const r=t.id.toString();return this.clear(r).prime(r,t),!0}async create(t,r,a){const i=await o.create(u(this,c),t,r,a);return this.cache(i),i}async deterministic(t,r){const a=await v(t);try{return await super.load(a)}catch{const n=await o.createFromGenesis(u(this,c),a.genesis,r);return this.cache(n),n}}async load(t){return await super.load(t)}}c=new WeakMap,s=new WeakMap;export{S as TileLoader,v as getDeterministicQuery,g as keyToQuery,h as keyToString};
//# sourceMappingURL=lib.mjs.map
