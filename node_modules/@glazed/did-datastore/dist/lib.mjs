import{StreamID as A}from"@ceramicnetwork/streamid";import{CIP11_INDEX_SCHEMA_URL as C,CIP11_DEFINITION_SCHEMA_URL as T}from"@glazed/constants";import{DataModel as M}from"@glazed/datamodel";import{TileLoader as U,getDeterministicQuery as V}from"@glazed/tile-loader";var E=(n,t,e)=>{if(!t.has(n))throw TypeError("Cannot "+e)},l=(n,t,e)=>(E(n,t,"read from private field"),e?e.call(n):t.get(n)),v=(n,t,e)=>{if(t.has(n))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(n):t.set(n,e)},x=(n,t,e,i)=>(E(n,t,"write to private field"),i?i.call(n,e):t.set(n,e),e),_,w,R,D;class ${constructor(t){v(this,_,void 0),v(this,w,[]),v(this,R,void 0),v(this,D,void 0),x(this,_,t),this._createValuePromise()}_createValuePromise(){x(this,R,new Promise((t,e)=>{x(this,D,{resolve:t,reject:e})}))}change(t){return new Promise((e,i)=>{const r=async a=>{try{const s=await t(a);e(),this._next(s)}catch(s){i(s),this._next(a)}};l(this,w).push({reject:i,run:r}),l(this,w).length===1&&this._start()})}async changeContent(t){const e=async i=>(await i.update(t(i.content),i.metadata),i);return await this.change(e)}async get(){return l(this,w).length===0?await l(this,_).call(this):await l(this,R)}async _start(){try{const t=await l(this,_).call(this);this._next(t)}catch(t){l(this,w).forEach(e=>{e.reject(t)}),x(this,w,[]),l(this,D).reject(t),this._createValuePromise()}}_next(t){const e=l(this,w).shift();e==null?this._end(t):e.run(t)}_end(t){l(this,D).resolve(t),this._createValuePromise()}}_=new WeakMap,w=new WeakMap,R=new WeakMap,D=new WeakMap;const z=/^did:([A-Za-z0-9]+):([A-Za-z0-9.\-:_]+)$/;function S(n){return z.test(n)}function W(n){if(!S(n))throw new Error(`Invalid DID: ${n}`)}function O(n){return W(n),{controllers:[n],family:"IDX"}}var X=(n,t,e)=>{if(!t.has(n))throw TypeError("Cannot "+e)},c=(n,t,e)=>(X(n,t,"read from private field"),e?e.call(n):t.get(n)),g=(n,t,e)=>{if(t.has(n))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(n):t.set(n,e)},m=(n,t,e,i)=>(X(n,t,"write to private field"),i?i.call(n,e):t.set(n,e),e),y,f,I,P,d,p;class L{constructor(t){g(this,y,void 0),g(this,f,void 0),g(this,I,void 0),g(this,P,{}),g(this,d,void 0),g(this,p,void 0);const{autopin:e,cache:i,ceramic:r,id:a,loader:s,model:o}=t;m(this,y,e!==!1),m(this,f,r),m(this,I,a),m(this,d,s??new U({ceramic:r,cache:i})),m(this,p,o instanceof M?o:new M({autopin:e,loader:c(this,d),model:o}))}get authenticated(){return c(this,f).did!=null}get ceramic(){return c(this,f)}get id(){if(c(this,I)!=null)return c(this,I);if(c(this,f).did==null)throw new Error("Ceramic instance is not authenticated");return c(this,f).did.id}get loader(){return c(this,d)}get model(){return c(this,p)}async has(t,e){const i=this.getDefinitionID(t);return await this.getRecordID(i,e)!=null}async get(t,e){const i=this.getDefinitionID(t);return await this.getRecord(i,e)}async getMultiple(t,e){const i=this.getDefinitionID(t),r=await Promise.all(e.map(async o=>{const{genesis:h,streamId:u}=await V(O(o));return{genesis:h,streamId:u.toString(),paths:[i]}})),a=await c(this,f).multiQuery(r),s=[];for(const o of r){const h=a[o.streamId]?.content?.[i],u=h?a[A.fromString(h).toString()]:null;s.push(u?.content??null)}return s}async set(t,e,i={}){const r=this.getDefinitionID(t),[a,s]=await this._setRecordOnly(r,e,i);return a&&await this._setReference(i.controller??this.id,r,s),s}async merge(t,e,i={}){const r=this.getDefinitionID(t),a=await this.getRecord(r),s=a?{...a,...e}:e;return await this.setRecord(r,s,i)}async setAll(t,e={}){const i=Object.entries(t).map(async([s,o])=>{const h=this.getDefinitionID(s),[u,k]=await this._setRecordOnly(h,o,e);return[u,h,k]}),a=(await Promise.all(i)).reduce((s,[o,h,u])=>(o&&(s[h]=u.toUrl()),s),{});return await this._setReferences(e.controller??this.id,a),a}async setDefaults(t,e={}){const i=await this.getIndex()??{},r=Object.entries(t).map(([o,h])=>[this.getDefinitionID(o),h]).filter(o=>i[o[0]]==null).map(async([o,h])=>{const u=await this.getDefinition(o),k=await this._createRecord(u,h,e);return{[o]:k.toUrl()}}),s=(await Promise.all(r)).reduce((o,h)=>Object.assign(o,h),{});return await this._setReferences(e.controller??this.id,s),s}async remove(t,e=this.id){await this._getIndexProxy(e).changeContent(i=>(i!=null&&delete i[this.getDefinitionID(t)],i))}async getIndex(t=this.id){const e=this.authenticated&&t===this.id?await this._getIndexProxy(t).get():await this._getIDXDoc(t);return e?e.content:null}iterator(t){let e,i=0;return{[Symbol.asyncIterator](){return this},next:async()=>{if(e==null){const o=await this.getIndex(t);e=Object.entries(o??{})}if(i===e.length)return{done:!0,value:null};const[r,a]=e[i++],s=await c(this,d).load(a);return{done:!1,value:{key:r,id:a,record:s.content}}}}}async _createIDXDoc(t){return await c(this,d).deterministic(O(t))}async _getIDXDoc(t){const e=await this._createIDXDoc(t);if(e.content==null||e.metadata.schema==null)return null;if(e.metadata.schema!==C)throw new Error("Invalid document: schema is not IdentityIndex");return e}async _getOwnIDXDoc(t){const e=await this._createIDXDoc(t);if(e.content==null||e.metadata.schema==null)await e.update({},{schema:C},{pin:c(this,y)});else if(e.metadata.schema!==C)throw new Error("Invalid document: schema is not IdentityIndex");return e}_getIndexProxy(t){let e=c(this,P)[t];return e==null&&(e=new $(async()=>await this._getOwnIDXDoc(t)),c(this,P)[t]=e),e}getDefinitionID(t){return c(this,p).getDefinitionID(t)??t}async getDefinition(t){const e=await c(this,d).load(t);if(e.metadata.schema!==T)throw new Error("Invalid document: schema is not Definition");return{...e.content,id:e.id}}async getRecordID(t,e){return(await this.getIndex(e??this.id))?.[t]??null}async getRecordDocument(t,e){const i=await this.getRecordID(t,e);return i?await c(this,d).load(i):null}async getRecord(t,e){const i=await this.getRecordDocument(t,e);return i?i.content:null}async setRecord(t,e,i={}){const[r,a]=await this._setRecordOnly(t,e,i);return r&&await this._setReference(i.controller??this.id,t,a),a}async _setRecordOnly(t,e,i){const r=await this.getRecordID(t,i.controller??this.id);if(r==null){const a=await this.getDefinition(t),s=await this._createRecord(a,e,i);return[!0,s]}else{const a=await c(this,d).load(r);return await a.update(e),[!1,a.id]}}async _createRecord(t,e,{controller:i,pin:r}){const a=await c(this,d).deterministic({controllers:[i??this.id],family:t.id.toString()});return await a.update(e,{schema:t.schema},{pin:r??c(this,y)}),a.id}async _setReference(t,e,i){await this._getIndexProxy(t).changeContent(r=>({...r,[e]:i.toUrl()}))}async _setReferences(t,e){Object.keys(e).length!==0&&await this._getIndexProxy(t).changeContent(i=>({...i,...e}))}}y=new WeakMap,f=new WeakMap,I=new WeakMap,P=new WeakMap,d=new WeakMap,p=new WeakMap;export{L as DIDDataStore,W as assertDIDstring,S as isDIDstring};
//# sourceMappingURL=lib.mjs.map
