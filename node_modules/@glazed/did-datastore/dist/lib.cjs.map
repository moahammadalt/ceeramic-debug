{"version":3,"file":"lib.cjs","sources":["../src/proxy.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import type { TileDocument } from '@ceramicnetwork/stream-tile'\n\nexport type TileContent = Record<string, any> | null | undefined\nexport type TileDoc = TileDocument<TileContent>\nexport type MutationFunc = (current: TileDoc) => Promise<TileDoc>\n\ntype RejectFunc = (error: Error) => void\n\ntype QueueItem<TileDoc> = {\n  reject: RejectFunc\n  run: (value: TileDoc) => Promise<void>\n}\n\nexport class TileProxy {\n  #getRemote: () => Promise<TileDoc>\n  #queue: Array<QueueItem<TileDoc>> = []\n  #promiseValue!: Promise<TileDoc>\n  #deferValue!: { resolve: (value: TileDoc) => any; reject: RejectFunc }\n\n  constructor(getRemote: () => Promise<TileDoc>) {\n    this.#getRemote = getRemote\n    this._createValuePromise()\n  }\n\n  /** @internal */\n  _createValuePromise(): void {\n    this.#promiseValue = new Promise((resolve, reject) => {\n      this.#deferValue = { resolve, reject }\n    })\n  }\n\n  change(mutation: MutationFunc): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const run = async (current: TileDoc): Promise<void> => {\n        try {\n          const next = await mutation(current)\n          resolve()\n          this._next(next)\n        } catch (err) {\n          reject(err)\n          this._next(current)\n        }\n      }\n\n      this.#queue.push({ reject, run })\n      if (this.#queue.length === 1) {\n        void this._start()\n      }\n    })\n  }\n\n  async changeContent(change: (content: TileContent) => TileContent): Promise<void> {\n    const mutation = async (doc: TileDoc): Promise<TileDoc> => {\n      await doc.update(change(doc.content), doc.metadata)\n      return doc\n    }\n    return await this.change(mutation)\n  }\n\n  async get(): Promise<TileDoc> {\n    return this.#queue.length === 0 ? await this.#getRemote() : await this.#promiseValue\n  }\n\n  /** @internal */\n  async _start(): Promise<void> {\n    try {\n      const value = await this.#getRemote()\n      this._next(value)\n    } catch (err) {\n      this.#queue.forEach((item) => {\n        item.reject(err as Error)\n      })\n      this.#queue = []\n      this.#deferValue.reject(err as Error)\n      this._createValuePromise()\n    }\n  }\n\n  /** @internal */\n  _next(value: TileDoc): void {\n    const item = this.#queue.shift()\n    if (item == null) {\n      this._end(value)\n    } else {\n      void item.run(value)\n    }\n  }\n\n  /** @internal */\n  _end(value: TileDoc): void {\n    this.#deferValue.resolve(value)\n    this._createValuePromise()\n  }\n}\n","import type { TileMetadataArgs } from '@ceramicnetwork/stream-tile'\n\nconst didRegex = /^did:([A-Za-z0-9]+):([A-Za-z0-9.\\-:_]+)$/\nexport function isDIDstring(did: string): boolean {\n  return didRegex.test(did)\n}\n\nexport function assertDIDstring(did: string): void {\n  if (!isDIDstring(did)) {\n    throw new Error(`Invalid DID: ${did}`)\n  }\n}\n\nexport function getIDXMetadata(did: string): TileMetadataArgs {\n  assertDIDstring(did)\n  return { controllers: [did], family: 'IDX' }\n}\n","/**\n * ```sh\n * npm install @glazed/did-datastore\n * ```\n *\n * @module did-datastore\n */\n\nimport type { CeramicApi } from '@ceramicnetwork/common'\nimport { StreamID } from '@ceramicnetwork/streamid'\nimport { CIP11_DEFINITION_SCHEMA_URL, CIP11_INDEX_SCHEMA_URL } from '@glazed/constants'\nimport { DataModel } from '@glazed/datamodel'\nimport type { Definition, IdentityIndex } from '@glazed/did-datastore-model'\nimport { TileLoader, getDeterministicQuery } from '@glazed/tile-loader'\nimport type { TileCache } from '@glazed/tile-loader'\nimport type { ModelTypeAliases, ModelTypesToAliases } from '@glazed/types'\n\nimport { TileProxy } from './proxy'\nimport type { TileDoc } from './proxy'\nimport { getIDXMetadata } from './utils'\n\nexport { assertDIDstring, isDIDstring } from './utils'\n\nexport type DefinitionContentType<\n  ModelTypes extends ModelTypeAliases,\n  Alias extends keyof ModelTypes['definitions']\n> = ModelTypes['schemas'][ModelTypes['definitions'][Alias]]\n\nexport type DefinitionsContentTypes<\n  ModelTypes extends ModelTypeAliases,\n  Fallback = Record<string, unknown>\n> = {\n  [Key: string]: typeof Key extends keyof ModelTypes['definitions']\n    ? DefinitionContentType<ModelTypes, typeof Key>\n    : Fallback\n}\n\nexport type DefinitionWithID<Config extends Record<string, unknown> = Record<string, unknown>> =\n  Definition<Config> & { id: StreamID }\n\nexport type Entry = {\n  /**\n   * Key (definition ID) identifying the record ID in the index\n   */\n  key: string\n  /**\n   * Record ID (Ceramic StreamID)\n   */\n  id: string\n  /**\n   * Record contents\n   */\n  record: unknown\n}\n\nexport type CreateOptions = {\n  /**\n   * Optional controller for the record\n   */\n  controller?: string\n  /**\n   * Pin the created record stream (default)\n   */\n  pin?: boolean\n}\n\nexport type DIDDataStoreParams<ModelTypes extends ModelTypeAliases = ModelTypeAliases> = {\n  /**\n   * Pin all created records streams (default)\n   */\n  autopin?: boolean\n  /**\n   * {@linkcode TileLoader} cache parameter, only used if `loader` is not provided\n   */\n  cache?: TileCache | boolean\n  /**\n   * A Ceramic client instance\n   */\n  ceramic: CeramicApi\n  /**\n   * Fallback DID to use when not explicitly set in method calls\n   */\n  id?: string\n  /**\n   * An optional {@linkcode TileLoader} instance to use\n   */\n  loader?: TileLoader\n  /**\n   * A {@linkcode DataModel} instance or runtime model aliases to use\n   */\n  model: DataModel<ModelTypes> | ModelTypesToAliases<ModelTypes>\n}\n\n/**\n * ```sh\n * import { DIDDataStore } from '@glazed/did-datastore'\n * ```\n */\nexport class DIDDataStore<\n  ModelTypes extends ModelTypeAliases = ModelTypeAliases,\n  Alias extends keyof ModelTypes['definitions'] = keyof ModelTypes['definitions']\n> {\n  #autopin: boolean\n  #ceramic: CeramicApi\n  #id: string | undefined\n  #indexProxies: Record<string, TileProxy> = {}\n  #loader: TileLoader\n  #model: DataModel<ModelTypes>\n\n  constructor(params: DIDDataStoreParams<ModelTypes>) {\n    const { autopin, cache, ceramic, id, loader, model } = params\n    this.#autopin = autopin !== false\n    this.#ceramic = ceramic\n    this.#id = id\n    this.#loader = loader ?? new TileLoader({ ceramic, cache })\n    this.#model =\n      model instanceof DataModel\n        ? model\n        : new DataModel<ModelTypes>({ autopin, loader: this.#loader, model })\n  }\n\n  get authenticated(): boolean {\n    return this.#ceramic.did != null\n  }\n\n  get ceramic(): CeramicApi {\n    return this.#ceramic\n  }\n\n  get id(): string {\n    if (this.#id != null) {\n      return this.#id\n    }\n    if (this.#ceramic.did == null) {\n      throw new Error('Ceramic instance is not authenticated')\n    }\n    return this.#ceramic.did.id\n  }\n\n  get loader(): TileLoader {\n    return this.#loader\n  }\n\n  get model(): DataModel<ModelTypes> {\n    return this.#model\n  }\n\n  // High-level APIs\n\n  /**\n   * Returns whether a record exists in the index or not.\n   */\n  async has(key: Alias, did?: string): Promise<boolean> {\n    const definitionID = this.getDefinitionID(key as string)\n    const ref = await this.getRecordID(definitionID, did)\n    return ref != null\n  }\n\n  /**\n   * Get the record contents.\n   */\n  async get<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(\n    key: Key,\n    did?: string\n  ): Promise<ContentType | null> {\n    const definitionID = this.getDefinitionID(key as string)\n    return await this.getRecord<ContentType>(definitionID, did)\n  }\n\n  /**\n   * Get the record contents for multiple DIDs at once.\n   */\n  async getMultiple<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(\n    key: Key,\n    dids: Array<string>\n  ): Promise<Array<ContentType | null>> {\n    const definitionID = this.getDefinitionID(key as string)\n    // Create determinitic queries for the IDX streams and add path of the definition\n    const queries = await Promise.all(\n      dids.map(async (did) => {\n        const { genesis, streamId } = await getDeterministicQuery(getIDXMetadata(did))\n        return { genesis, streamId: streamId.toString(), paths: [definitionID] }\n      })\n    )\n    const streams = await this.#ceramic.multiQuery(queries)\n    const results = []\n    for (const query of queries) {\n      // Lookup the record ID in the index to access the record contents\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      const recordURL = streams[query.streamId]?.content?.[definitionID] as string | undefined\n      // Record IDs are set in URL format in the index, but string format in the streams object\n      const record = recordURL ? streams[StreamID.fromString(recordURL).toString()] : null\n      results.push((record?.content as ContentType) ?? null)\n    }\n    return results\n  }\n\n  /**\n   * Set the record contents.\n   *\n   * **Warning**: calling this method replaces any existing contents in the record, use {@linkcode merge} if you want to only change some fields.\n   */\n  async set<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(\n    key: Key,\n    content: ContentType,\n    options: CreateOptions = {}\n  ): Promise<StreamID> {\n    const definitionID = this.getDefinitionID(key as string)\n    const [created, id] = await this._setRecordOnly(definitionID, content, options)\n    if (created) {\n      await this._setReference(options.controller ?? this.id, definitionID, id)\n    }\n    return id\n  }\n\n  /**\n   * Perform a shallow (one level) merge of the record contents.\n   */\n  async merge<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(\n    key: Key,\n    content: ContentType,\n    options: CreateOptions = {}\n  ): Promise<StreamID> {\n    const definitionID = this.getDefinitionID(key as string)\n    const existing = await this.getRecord<ContentType>(definitionID)\n    const newContent = existing ? { ...existing, ...content } : content\n    return await this.setRecord(definitionID, newContent, options)\n  }\n\n  /**\n   * Set the contents of multiple records at once.\n   * The index only gets updated after all wanted records have been written.\n   *\n   * **Warning**: calling this method replaces any existing contents in the records.\n   */\n  async setAll<Contents extends DefinitionsContentTypes<ModelTypes>>(\n    contents: Contents,\n    options: CreateOptions = {}\n  ): Promise<IdentityIndex> {\n    const updates = Object.entries(contents).map(async ([alias, content]) => {\n      const definitionID = this.getDefinitionID(alias)\n      const [created, id] = await this._setRecordOnly(definitionID, content, options)\n      return [created, definitionID, id]\n    }) as Array<Promise<[boolean, string, StreamID]>>\n    const changes = await Promise.all(updates)\n\n    const newReferences = changes.reduce((acc, [created, key, id]) => {\n      if (created) {\n        acc[key] = id.toUrl()\n      }\n      return acc\n    }, {} as IdentityIndex)\n    await this._setReferences(options.controller ?? this.id, newReferences)\n\n    return newReferences\n  }\n\n  /**\n   * Set the contents of multiple records if they are not already set in the index.\n   */\n  async setDefaults<Contents extends DefinitionsContentTypes<ModelTypes>>(\n    contents: Contents,\n    options: CreateOptions = {}\n  ): Promise<IdentityIndex> {\n    const index = (await this.getIndex()) ?? {}\n\n    const updates = Object.entries(contents)\n      .map(([alias, content]): [string, Record<string, unknown>] => [\n        this.getDefinitionID(alias),\n        content,\n      ])\n      .filter((entry) => index[entry[0]] == null)\n      .map(async ([key, content]) => {\n        const definition = await this.getDefinition(key)\n        const id = await this._createRecord(definition, content, options)\n        return { [key]: id.toUrl() }\n      }) as Array<Promise<IdentityIndex>>\n    const changes = await Promise.all(updates)\n\n    const newReferences = changes.reduce((acc, keyToID) => {\n      return Object.assign(acc, keyToID)\n    }, {} as IdentityIndex)\n    await this._setReferences(options.controller ?? this.id, newReferences)\n\n    return newReferences\n  }\n\n  /**\n   * Remove a record from the index.\n   *\n   * **Notice**: this *does not* change the contents of the record itself, only the index.\n   */\n  async remove(key: Alias, controller = this.id): Promise<void> {\n    await this._getIndexProxy(controller).changeContent((index) => {\n      if (index != null) {\n        delete index[this.getDefinitionID(key as string)]\n      }\n      return index\n    })\n  }\n\n  // Identity Index APIs\n\n  /**\n   * Load the full index contents.\n   */\n  async getIndex(did = this.id): Promise<IdentityIndex | null> {\n    const rootDoc =\n      this.authenticated && did === this.id\n        ? await this._getIndexProxy(did).get()\n        : await this._getIDXDoc(did)\n    return rootDoc ? (rootDoc.content as IdentityIndex) : null\n  }\n\n  /**\n   * Asynchronously iterate over the entries of the index, loading one record at a time.\n   */\n  iterator(did?: string): AsyncIterableIterator<Entry> {\n    let list: Array<[string, string]>\n    let cursor = 0\n\n    return {\n      [Symbol.asyncIterator]() {\n        return this\n      },\n      next: async (): Promise<IteratorResult<Entry>> => {\n        if (list == null) {\n          const index = await this.getIndex(did)\n          list = Object.entries(index ?? {})\n        }\n        if (cursor === list.length) {\n          return { done: true, value: null }\n        }\n\n        const [key, id] = list[cursor++]\n        const doc = await this.#loader.load(id)\n        return { done: false, value: { key, id, record: doc.content } }\n      },\n    }\n  }\n\n  /** @internal */\n  async _createIDXDoc(controller: string): Promise<TileDoc> {\n    return await this.#loader.deterministic(getIDXMetadata(controller))\n  }\n\n  /** @internal */\n  async _getIDXDoc(did: string): Promise<TileDoc | null> {\n    const doc = await this._createIDXDoc(did)\n    if (doc.content == null || doc.metadata.schema == null) {\n      return null\n    }\n    if (doc.metadata.schema !== CIP11_INDEX_SCHEMA_URL) {\n      throw new Error('Invalid document: schema is not IdentityIndex')\n    }\n    return doc\n  }\n\n  /** @internal */\n  async _getOwnIDXDoc(did: string): Promise<TileDoc> {\n    const doc = await this._createIDXDoc(did)\n    if (doc.content == null || doc.metadata.schema == null) {\n      // Doc just got created, set to empty object with schema\n      await doc.update({}, { schema: CIP11_INDEX_SCHEMA_URL }, { pin: this.#autopin })\n    } else if (doc.metadata.schema !== CIP11_INDEX_SCHEMA_URL) {\n      throw new Error('Invalid document: schema is not IdentityIndex')\n    }\n    return doc\n  }\n\n  /** @internal */\n  _getIndexProxy(controller: string): TileProxy {\n    let proxy = this.#indexProxies[controller]\n    if (proxy == null) {\n      proxy = new TileProxy(async () => await this._getOwnIDXDoc(controller))\n      this.#indexProxies[controller] = proxy\n    }\n    return proxy\n  }\n\n  // Definition APIs\n\n  /**\n   * Get the definition ID for the given alias.\n   */\n  getDefinitionID(aliasOrID: string): string {\n    return this.#model.getDefinitionID(aliasOrID) ?? aliasOrID\n  }\n\n  /**\n   * Load and validate a definition by its ID.\n   */\n  async getDefinition(id: StreamID | string): Promise<DefinitionWithID> {\n    const doc = await this.#loader.load(id)\n    if (doc.metadata.schema !== CIP11_DEFINITION_SCHEMA_URL) {\n      throw new Error('Invalid document: schema is not Definition')\n    }\n    return { ...doc.content, id: doc.id } as DefinitionWithID\n  }\n\n  // Record APIs\n\n  /**\n   * Load a record ID in the index for the given definition ID.\n   */\n  async getRecordID(definitionID: string, did?: string): Promise<string | null> {\n    const index = await this.getIndex(did ?? this.id)\n    return index?.[definitionID] ?? null\n  }\n\n  /**\n   * Load a record TileDocument for the given definition ID.\n   */\n  async getRecordDocument(definitionID: string, did?: string): Promise<TileDoc | null> {\n    const id = await this.getRecordID(definitionID, did)\n    return id ? await this.#loader.load(id) : null\n  }\n\n  /**\n   * Load a record contents for the given definition ID.\n   */\n  async getRecord<ContentType = unknown>(\n    definitionID: string,\n    did?: string\n  ): Promise<ContentType | null> {\n    const doc = await this.getRecordDocument(definitionID, did)\n    return doc ? (doc.content as ContentType) : null\n  }\n\n  /**\n   * Set the contents of a record for the given definition ID.\n   */\n  async setRecord(\n    definitionID: string,\n    content: Record<string, any>,\n    options: CreateOptions = {}\n  ): Promise<StreamID> {\n    const [created, id] = await this._setRecordOnly(definitionID, content, options)\n    if (created) {\n      await this._setReference(options.controller ?? this.id, definitionID, id)\n    }\n    return id\n  }\n\n  /** @internal */\n  async _setRecordOnly(\n    definitionID: string,\n    content: Record<string, any>,\n    options: CreateOptions\n  ): Promise<[boolean, StreamID]> {\n    const existing = await this.getRecordID(definitionID, options.controller ?? this.id)\n    if (existing == null) {\n      const definition = await this.getDefinition(definitionID)\n      const ref = await this._createRecord(definition, content, options)\n      return [true, ref]\n    } else {\n      const doc = await this.#loader.load(existing)\n      await doc.update(content)\n      return [false, doc.id]\n    }\n  }\n\n  /** @internal */\n  async _createRecord(\n    definition: DefinitionWithID,\n    content: Record<string, any>,\n    { controller, pin }: CreateOptions\n  ): Promise<StreamID> {\n    // Doc must first be created in a deterministic way\n    const doc = await this.#loader.deterministic({\n      controllers: [controller ?? this.id],\n      family: definition.id.toString(),\n    })\n    // Then be updated with content and schema\n    await doc.update(content, { schema: definition.schema }, { pin: pin ?? this.#autopin })\n    return doc.id\n  }\n\n  // References APIs\n\n  /** @internal */\n  async _setReference(controller: string, definitionID: string, id: StreamID): Promise<void> {\n    await this._getIndexProxy(controller).changeContent((index) => {\n      return { ...index, [definitionID]: id.toUrl() }\n    })\n  }\n\n  /** @internal */\n  async _setReferences(controller: string, references: IdentityIndex): Promise<void> {\n    if (Object.keys(references).length !== 0) {\n      await this._getIndexProxy(controller).changeContent((index) => {\n        return { ...index, ...references }\n      })\n    }\n  }\n}\n"],"names":["__privateGet","TileLoader","DataModel","getDeterministicQuery","StreamID","CIP11_INDEX_SCHEMA_URL","CIP11_DEFINITION_SCHEMA_URL"],"mappings":"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"}