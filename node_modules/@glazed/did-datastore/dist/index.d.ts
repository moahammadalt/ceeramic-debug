/**
 * ```sh
 * npm install @glazed/did-datastore
 * ```
 *
 * @module did-datastore
 */
import type { CeramicApi } from '@ceramicnetwork/common';
import { StreamID } from '@ceramicnetwork/streamid';
import { DataModel } from '@glazed/datamodel';
import type { Definition, IdentityIndex } from '@glazed/did-datastore-model';
import { TileLoader } from '@glazed/tile-loader';
import type { TileCache } from '@glazed/tile-loader';
import type { ModelTypeAliases, ModelTypesToAliases } from '@glazed/types';
import { TileProxy } from './proxy';
import type { TileDoc } from './proxy';
export { assertDIDstring, isDIDstring } from './utils';
export declare type DefinitionContentType<ModelTypes extends ModelTypeAliases, Alias extends keyof ModelTypes['definitions']> = ModelTypes['schemas'][ModelTypes['definitions'][Alias]];
export declare type DefinitionsContentTypes<ModelTypes extends ModelTypeAliases, Fallback = Record<string, unknown>> = {
    [Key: string]: typeof Key extends keyof ModelTypes['definitions'] ? DefinitionContentType<ModelTypes, typeof Key> : Fallback;
};
export declare type DefinitionWithID<Config extends Record<string, unknown> = Record<string, unknown>> = Definition<Config> & {
    id: StreamID;
};
export declare type Entry = {
    /**
     * Key (definition ID) identifying the record ID in the index
     */
    key: string;
    /**
     * Record ID (Ceramic StreamID)
     */
    id: string;
    /**
     * Record contents
     */
    record: unknown;
};
export declare type CreateOptions = {
    /**
     * Optional controller for the record
     */
    controller?: string;
    /**
     * Pin the created record stream (default)
     */
    pin?: boolean;
};
export declare type DIDDataStoreParams<ModelTypes extends ModelTypeAliases = ModelTypeAliases> = {
    /**
     * Pin all created records streams (default)
     */
    autopin?: boolean;
    /**
     * {@linkcode TileLoader} cache parameter, only used if `loader` is not provided
     */
    cache?: TileCache | boolean;
    /**
     * A Ceramic client instance
     */
    ceramic: CeramicApi;
    /**
     * Fallback DID to use when not explicitly set in method calls
     */
    id?: string;
    /**
     * An optional {@linkcode TileLoader} instance to use
     */
    loader?: TileLoader;
    /**
     * A {@linkcode DataModel} instance or runtime model aliases to use
     */
    model: DataModel<ModelTypes> | ModelTypesToAliases<ModelTypes>;
};
/**
 * ```sh
 * import { DIDDataStore } from '@glazed/did-datastore'
 * ```
 */
export declare class DIDDataStore<ModelTypes extends ModelTypeAliases = ModelTypeAliases, Alias extends keyof ModelTypes['definitions'] = keyof ModelTypes['definitions']> {
    #private;
    constructor(params: DIDDataStoreParams<ModelTypes>);
    get authenticated(): boolean;
    get ceramic(): CeramicApi;
    get id(): string;
    get loader(): TileLoader;
    get model(): DataModel<ModelTypes>;
    /**
     * Returns whether a record exists in the index or not.
     */
    has(key: Alias, did?: string): Promise<boolean>;
    /**
     * Get the record contents.
     */
    get<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(key: Key, did?: string): Promise<ContentType | null>;
    /**
     * Get the record contents for multiple DIDs at once.
     */
    getMultiple<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(key: Key, dids: Array<string>): Promise<Array<ContentType | null>>;
    /**
     * Set the record contents.
     *
     * **Warning**: calling this method replaces any existing contents in the record, use {@linkcode merge} if you want to only change some fields.
     */
    set<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(key: Key, content: ContentType, options?: CreateOptions): Promise<StreamID>;
    /**
     * Perform a shallow (one level) merge of the record contents.
     */
    merge<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(key: Key, content: ContentType, options?: CreateOptions): Promise<StreamID>;
    /**
     * Set the contents of multiple records at once.
     * The index only gets updated after all wanted records have been written.
     *
     * **Warning**: calling this method replaces any existing contents in the records.
     */
    setAll<Contents extends DefinitionsContentTypes<ModelTypes>>(contents: Contents, options?: CreateOptions): Promise<IdentityIndex>;
    /**
     * Set the contents of multiple records if they are not already set in the index.
     */
    setDefaults<Contents extends DefinitionsContentTypes<ModelTypes>>(contents: Contents, options?: CreateOptions): Promise<IdentityIndex>;
    /**
     * Remove a record from the index.
     *
     * **Notice**: this *does not* change the contents of the record itself, only the index.
     */
    remove(key: Alias, controller?: string): Promise<void>;
    /**
     * Load the full index contents.
     */
    getIndex(did?: string): Promise<IdentityIndex | null>;
    /**
     * Asynchronously iterate over the entries of the index, loading one record at a time.
     */
    iterator(did?: string): AsyncIterableIterator<Entry>;
    /** @internal */
    _createIDXDoc(controller: string): Promise<TileDoc>;
    /** @internal */
    _getIDXDoc(did: string): Promise<TileDoc | null>;
    /** @internal */
    _getOwnIDXDoc(did: string): Promise<TileDoc>;
    /** @internal */
    _getIndexProxy(controller: string): TileProxy;
    /**
     * Get the definition ID for the given alias.
     */
    getDefinitionID(aliasOrID: string): string;
    /**
     * Load and validate a definition by its ID.
     */
    getDefinition(id: StreamID | string): Promise<DefinitionWithID>;
    /**
     * Load a record ID in the index for the given definition ID.
     */
    getRecordID(definitionID: string, did?: string): Promise<string | null>;
    /**
     * Load a record TileDocument for the given definition ID.
     */
    getRecordDocument(definitionID: string, did?: string): Promise<TileDoc | null>;
    /**
     * Load a record contents for the given definition ID.
     */
    getRecord<ContentType = unknown>(definitionID: string, did?: string): Promise<ContentType | null>;
    /**
     * Set the contents of a record for the given definition ID.
     */
    setRecord(definitionID: string, content: Record<string, any>, options?: CreateOptions): Promise<StreamID>;
    /** @internal */
    _setRecordOnly(definitionID: string, content: Record<string, any>, options: CreateOptions): Promise<[boolean, StreamID]>;
    /** @internal */
    _createRecord(definition: DefinitionWithID, content: Record<string, any>, { controller, pin }: CreateOptions): Promise<StreamID>;
    /** @internal */
    _setReference(controller: string, definitionID: string, id: StreamID): Promise<void>;
    /** @internal */
    _setReferences(controller: string, references: IdentityIndex): Promise<void>;
}
