'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var streamid = require('@ceramicnetwork/streamid');
var streamTile = require('@ceramicnetwork/stream-tile');
var constants = require('@glazed/constants');
var didDatastoreModel = require('@glazed/did-datastore-model');
var CID = require('cids');
var uint8arrays = require('uint8arrays');
var changeCase = require('change-case');
var Ajv = require('ajv');
var addFormats = require('ajv-formats');
var SecureSchema = require('ajv/lib/refs/json-schema-secure.json');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var CID__default = /*#__PURE__*/_interopDefaultLegacy(CID);
var Ajv__default = /*#__PURE__*/_interopDefaultLegacy(Ajv);
var addFormats__default = /*#__PURE__*/_interopDefaultLegacy(addFormats);
var SecureSchema__default = /*#__PURE__*/_interopDefaultLegacy(SecureSchema);

function streamIDToString(id) {
  return typeof id === "string" ? id : id.toString();
}
function applyMap(inputs, callFunc) {
  return Object.entries(inputs).reduce((acc, [key, value]) => {
    acc[key] = callFunc(value);
    return acc;
  }, {});
}
async function promiseMap(inputs, callFunc) {
  const results = await Promise.all(Object.values(inputs).map((value) => callFunc(value)));
  return Object.keys(inputs).reduce((acc, key, i) => {
    acc[key] = results[i];
    return acc;
  }, {});
}

function decodeDagJWS({ payload, signatures, link }) {
  return { payload, signatures, link: link ? new CID__default['default'](link) : void 0 };
}
function encodeDagJWS({ payload, signatures, link }) {
  return { payload, signatures, link: link?.toString() };
}
function decodeDagJWSResult({ jws, linkedBlock }) {
  return { jws: decodeDagJWS(jws), linkedBlock: uint8arrays.fromString(linkedBlock, "base64pad") };
}
function encodeDagJWSResult({ jws, linkedBlock }) {
  return { jws: encodeDagJWS(jws), linkedBlock: uint8arrays.toString(linkedBlock, "base64pad") };
}
function decodeSignedMap(data) {
  return applyMap(data, (records) => records.map(decodeDagJWSResult));
}
function encodeSignedMap(data) {
  return applyMap(data, (records) => records.map(encodeDagJWSResult));
}
function decodeEntryCommits(entry) {
  return { ...entry, commits: entry.commits.map(decodeDagJWSResult) };
}
function decodeModel(model) {
  return {
    schemas: applyMap(model.schemas, (schema) => {
      return { ...schema, commits: schema.commits.map(decodeDagJWSResult) };
    }),
    definitions: applyMap(model.definitions, decodeEntryCommits),
    tiles: applyMap(model.tiles, decodeEntryCommits)
  };
}
function encodeEntryCommits(entry) {
  return { ...entry, commits: entry.commits.map(encodeDagJWSResult) };
}
function encodeModel(model) {
  return {
    schemas: applyMap(model.schemas, (schema) => {
      return { ...schema, commits: schema.commits.map(encodeDagJWSResult) };
    }),
    definitions: applyMap(model.definitions, encodeEntryCommits),
    tiles: applyMap(model.tiles, encodeEntryCommits)
  };
}

const PUBLISH_OPTS = { anchor: false };
async function createModelDoc(ceramic, content, metadata = {}) {
  const doc = await streamTile.TileDocument.create(ceramic, content, metadata, PUBLISH_OPTS);
  await ceramic.pin.add(doc.id);
  return doc;
}
async function publishCommits(ceramic, [genesis, ...updates]) {
  const doc = await streamTile.TileDocument.createFromGenesis(ceramic, genesis, PUBLISH_OPTS);
  await ceramic.pin.add(doc.id);
  for (const commit of updates) {
    await ceramic.applyCommit(doc.id, commit, PUBLISH_OPTS);
  }
  return doc;
}
async function publishSignedMap(ceramic, signed) {
  return await promiseMap(signed, async (commits) => await publishCommits(ceramic, commits));
}

function getReference(schema) {
  if (schema.$comment?.startsWith(constants.CIP88_REF_PREFIX)) {
    const schemasString = schema.$comment.substr(constants.CIP88_REF_PREFIX.length);
    if (schemasString.length) {
      const schemas = schemasString.split("|");
      schemas.sort();
      return schemas;
    }
  }
  return null;
}
function extractSchemaReferences(schema, path = "") {
  if (schema.type === "string") {
    const refs = getReference(schema);
    return refs != null && refs.length > 0 ? { [path]: refs } : {};
  }
  if (schema.type === "array") {
    return extractSchemaReferences(schema.items, path);
  }
  if (schema.type === "object" && schema.properties != null) {
    return Object.entries(schema.properties).reduce((acc, [key, prop]) => {
      const propPath = path === "" ? key : `${path}.${key}`;
      return Object.assign(acc, extractSchemaReferences(prop, propPath));
    }, {});
  }
  return {};
}

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _aliases, _ceramic, _model, _referenced, _streams;
function getManagedIDAndVersion(id) {
  const streamID = typeof id === "string" ? streamid.StreamRef.from(id) : id;
  return [streamID.baseID.toString(), streamid.CommitID.isInstance(streamID) ? streamID.toString() : null];
}
function getManagedID(id) {
  const streamID = typeof id === "string" ? streamid.StreamRef.from(id) : id;
  return streamID.baseID.toString();
}
function isSupportedDID(did) {
  return did.startsWith("did:key");
}
function docHasSupportedDID(doc) {
  return isSupportedDID(doc.metadata.controllers[0]);
}
const dataStoreModel = decodeModel(didDatastoreModel.model);
async function publishDataStoreSchemas(ceramic) {
  await Promise.all(Object.values(dataStoreModel.schemas).map(async (schema) => {
    return await publishCommits(ceramic, schema.commits);
  }));
}
async function publishModel(ceramic, model) {
  const [schemas] = await Promise.all([
    Promise.all(Object.values(model.schemas).map(async (schema) => {
      const stream = await publishCommits(ceramic, schema.commits);
      return [schema.alias, stream.commitId.toUrl()];
    })),
    publishDataStoreSchemas(ceramic)
  ]);
  const [definitions, tiles] = await Promise.all([
    await Promise.all(Object.values(model.definitions).map(async (entry) => {
      const stream = await publishCommits(ceramic, entry.commits);
      return [entry.alias, stream.id.toString()];
    })),
    await Promise.all(Object.values(model.tiles).map(async (entry) => {
      const stream = await publishCommits(ceramic, entry.commits);
      return [entry.alias, stream.id.toString()];
    }))
  ]);
  return {
    definitions: Object.fromEntries(definitions),
    schemas: Object.fromEntries(schemas),
    tiles: Object.fromEntries(tiles)
  };
}
async function publishEncodedModel(ceramic, model) {
  return await publishModel(ceramic, decodeModel(model));
}
const _ModelManager = class {
  constructor(ceramic, model) {
    __privateAdd(this, _aliases, {
      definitions: {},
      schemas: {},
      tiles: {}
    });
    __privateAdd(this, _ceramic, void 0);
    __privateAdd(this, _model, {
      definitions: {},
      schemas: {},
      tiles: {}
    });
    __privateAdd(this, _referenced, {});
    __privateAdd(this, _streams, {});
    __privateSet(this, _ceramic, ceramic);
    if (model != null) {
      this.addModel(model);
    }
  }
  static fromJSON(ceramic, encoded) {
    return new _ModelManager(ceramic, decodeModel(encoded));
  }
  get model() {
    return __privateGet(this, _model);
  }
  get schemas() {
    return Object.keys(__privateGet(this, _aliases).schemas).sort();
  }
  get definitions() {
    return Object.keys(__privateGet(this, _aliases).definitions).sort();
  }
  get tiles() {
    return Object.keys(__privateGet(this, _aliases).tiles).sort();
  }
  addModel(model) {
    Object.assign(__privateGet(this, _model).definitions, model.definitions);
    Object.assign(__privateGet(this, _model).schemas, model.schemas);
    Object.assign(__privateGet(this, _model).tiles, model.tiles);
    for (const [id, schema] of Object.entries(model.schemas)) {
      __privateGet(this, _aliases).schemas[schema.alias] = id;
      for (const refIDs of Object.values(schema.dependencies)) {
        for (const refID of refIDs) {
          if (__privateGet(this, _referenced)[refID] == null) {
            __privateGet(this, _referenced)[refID] = {
              definitions: new Set(),
              schemas: new Set(),
              tiles: new Set()
            };
          }
          __privateGet(this, _referenced)[refID].schemas.add(id);
        }
      }
    }
    for (const [id, definition] of Object.entries(model.definitions)) {
      __privateGet(this, _aliases).definitions[definition.alias] = id;
      if (__privateGet(this, _referenced)[definition.schema] == null) {
        __privateGet(this, _referenced)[definition.schema] = {
          definitions: new Set(),
          schemas: new Set(),
          tiles: new Set()
        };
      }
      __privateGet(this, _referenced)[definition.schema].definitions.add(id);
    }
    for (const [id, tile] of Object.entries(model.tiles)) {
      __privateGet(this, _aliases).tiles[tile.alias] = id;
      if (__privateGet(this, _referenced)[tile.schema] == null) {
        __privateGet(this, _referenced)[tile.schema] = {
          definitions: new Set(),
          schemas: new Set(),
          tiles: new Set()
        };
      }
      __privateGet(this, _referenced)[tile.schema].tiles.add(id);
    }
  }
  addJSONModel(encoded) {
    this.addModel(decodeModel(encoded));
  }
  async loadStream(streamID) {
    const id = typeof streamID === "string" ? streamID : streamID.baseID.toString();
    if (__privateGet(this, _streams)[id] == null) {
      __privateGet(this, _streams)[id] = this._loadAndValidateStream(id);
    }
    return await __privateGet(this, _streams)[id];
  }
  async _loadAndValidateStream(id) {
    const stream = await streamTile.TileDocument.load(__privateGet(this, _ceramic), id);
    if (stream.anchorCommitIds.length !== 0) {
      throw new Error(`Invalid stream ${id}: contains anchor commit`);
    }
    if (stream.allCommitIds.length === 1 && docHasSupportedDID(stream)) {
      return stream;
    }
    const commits = await Promise.all(stream.allCommitIds.map(async (commitID) => {
      return await streamTile.TileDocument.load(__privateGet(this, _ceramic), commitID);
    }));
    const unsupported = commits.find((commit) => !docHasSupportedDID(commit));
    if (unsupported != null) {
      throw new Error(`Invalid stream ${id}: contains a commit authored by an unsupported DID`);
    }
    return stream;
  }
  async loadCommits(id) {
    const commits = await __privateGet(this, _ceramic).loadStreamCommits(id);
    return commits.map((r) => r.value);
  }
  async loadSchema(id, alias) {
    const [managedID, commitID] = getManagedIDAndVersion(id);
    if (commitID === null) {
      throw new Error(`Expected CommitID to load schema: ${managedID}`);
    }
    const existing = __privateGet(this, _model).schemas[managedID];
    if (existing != null) {
      if (existing.version !== commitID) {
        throw new Error(`Another version for this schema is already set: ${existing.version}`);
      }
      if (alias != null && existing.alias !== alias) {
        throw new Error(`Another alias for this schema is already set: ${existing.alias}`);
      }
      return managedID;
    }
    const [stream, commits] = await Promise.all([
      this.loadStream(commitID),
      this.loadCommits(managedID)
    ]);
    const content = stream.content ?? {};
    const name = alias ?? content.title;
    if (name == null) {
      throw new Error("Schema must have a title property or an alias must be provided");
    }
    const dependencies = await this.loadSchemaDependencies(content);
    __privateGet(this, _model).schemas[managedID] = { alias: name, commits, dependencies, version: commitID };
    __privateGet(this, _aliases).schemas[name] = managedID;
    return managedID;
  }
  async loadSchemaDependencies(schema) {
    const references = extractSchemaReferences(schema);
    const ids = new Set();
    for (const refs of Object.values(references)) {
      for (const ref of refs) {
        ids.add(ref);
      }
    }
    const loaded = await Promise.all(Array.from(ids).map(async (id) => [id, await this.loadSchema(id)]));
    const idToManaged = Object.fromEntries(loaded);
    return Object.entries(references).reduce((acc, [path, deps]) => {
      acc[path] = deps.map((id) => idToManaged[id]);
      return acc;
    }, {});
  }
  async create(type, alias, content, meta) {
    switch (type) {
      case "schema":
        return await this.createSchema(alias, content);
      case "definition":
        return await this.createDefinition(alias, content);
      case "tile":
        return await this.createTile(alias, content, meta);
      default:
        throw new Error(`Unsupported type: ${type}`);
    }
  }
  async usePublished(type, alias, id) {
    switch (type) {
      case "schema":
        return await this.usePublishedSchema(alias, id);
      case "definition":
        return await this.usePublishedDefinition(alias, id);
      case "tile":
        return await this.usePublishedTile(alias, id);
      default:
        throw new Error(`Unsupported type: ${type}`);
    }
  }
  getSchemaID(alias) {
    return __privateGet(this, _aliases).schemas[alias] ?? null;
  }
  hasSchemaAlias(alias) {
    return this.getSchemaID(alias) != null;
  }
  getSchema(id) {
    return __privateGet(this, _model).schemas[id] ?? null;
  }
  getSchemaURL(id) {
    const schema = __privateGet(this, _model).schemas[id];
    return schema ? streamid.CommitID.fromString(schema.version).toUrl() : null;
  }
  getSchemaByAlias(alias) {
    const id = this.getSchemaID(alias);
    return id ? this.getSchema(id) : null;
  }
  async createSchema(alias, schema) {
    if (__privateGet(this, _ceramic).did == null || !__privateGet(this, _ceramic).did.authenticated) {
      throw new Error("Ceramic instance must be authenticated");
    }
    if (!isSupportedDID(__privateGet(this, _ceramic).did.id)) {
      throw new Error(`Invalid DID ${__privateGet(this, _ceramic).did.id} to create stream for model, only "did:key" is supported`);
    }
    if (this.hasSchemaAlias(alias)) {
      throw new Error(`Schema ${alias} already exists`);
    }
    const [stream, dependencies] = await Promise.all([
      createModelDoc(__privateGet(this, _ceramic), schema),
      this.loadSchemaDependencies(schema)
    ]);
    const id = stream.id.toString();
    __privateGet(this, _model).schemas[id] = {
      alias,
      commits: await this.loadCommits(id),
      dependencies,
      version: stream.commitId.toString()
    };
    __privateGet(this, _aliases).schemas[alias] = id;
    return id;
  }
  async usePublishedSchema(alias, id) {
    if (alias == null) {
      throw new Error("Schema alias must be provided");
    }
    return await this.loadSchema(id, alias);
  }
  getDefinitionID(alias) {
    return __privateGet(this, _aliases).definitions[alias] ?? null;
  }
  hasDefinitionAlias(alias) {
    return this.getDefinitionID(alias) != null;
  }
  getDefinition(id) {
    return __privateGet(this, _model).definitions[id] ?? null;
  }
  async createDefinition(alias, definition) {
    if (__privateGet(this, _ceramic).did == null || !__privateGet(this, _ceramic).did.authenticated) {
      throw new Error("Ceramic instance must be authenticated");
    }
    if (!isSupportedDID(__privateGet(this, _ceramic).did.id)) {
      throw new Error(`Invalid DID ${__privateGet(this, _ceramic).did.id} to create stream for model, only "did:key" is supported`);
    }
    if (this.hasDefinitionAlias(alias)) {
      throw new Error(`Definition ${alias} already exists`);
    }
    await publishDataStoreSchemas(__privateGet(this, _ceramic));
    const [stream, schemaID] = await Promise.all([
      createModelDoc(__privateGet(this, _ceramic), definition, { schema: constants.CIP11_DEFINITION_SCHEMA_URL }),
      this.loadSchema(definition.schema)
    ]);
    const id = stream.id.toString();
    __privateGet(this, _model).definitions[id] = {
      alias,
      commits: await this.loadCommits(id),
      schema: schemaID,
      version: stream.commitId.toString()
    };
    __privateGet(this, _aliases).definitions[alias] = id;
    return id;
  }
  async usePublishedDefinition(alias, id) {
    if (this.hasDefinitionAlias(alias)) {
      throw new Error(`Definition ${alias} already exists`);
    }
    const definitionID = getManagedID(id);
    const [stream, commits] = await Promise.all([
      this.loadStream(id),
      this.loadCommits(definitionID)
    ]);
    __privateGet(this, _model).definitions[definitionID] = {
      alias,
      commits,
      schema: await this.loadSchema(stream.content.schema),
      version: stream.commitId.toString()
    };
    __privateGet(this, _aliases).definitions[alias] = definitionID;
    return definitionID;
  }
  getTileID(alias) {
    return __privateGet(this, _aliases).tiles[alias] ?? null;
  }
  hasTileAlias(alias) {
    return this.getTileID(alias) != null;
  }
  getTile(id) {
    return __privateGet(this, _model).tiles[id] ?? null;
  }
  async createTile(alias, contents, meta = {}) {
    if (__privateGet(this, _ceramic).did == null || !__privateGet(this, _ceramic).did.authenticated) {
      throw new Error("Ceramic instance must be authenticated");
    }
    if (!isSupportedDID(__privateGet(this, _ceramic).did.id)) {
      throw new Error("Unsupported DID to create stream for model");
    }
    if (this.hasTileAlias(alias)) {
      throw new Error(`Tile ${alias} already exists`);
    }
    if (meta.schema == null) {
      throw new Error(`Missing schema to create tile ${alias}`);
    }
    const [stream, schemaID] = await Promise.all([
      createModelDoc(__privateGet(this, _ceramic), contents, meta),
      this.loadSchema(meta.schema)
    ]);
    const id = stream.id.toString();
    __privateGet(this, _model).tiles[id] = {
      alias,
      commits: await this.loadCommits(id),
      schema: schemaID,
      version: stream.commitId.toString()
    };
    __privateGet(this, _aliases).tiles[alias] = id;
    return id;
  }
  async usePublishedTile(alias, id) {
    if (this.hasTileAlias(alias)) {
      throw new Error(`Tile ${alias} already exists`);
    }
    const tileID = getManagedID(id);
    const [stream, commits] = await Promise.all([this.loadStream(id), this.loadCommits(tileID)]);
    if (stream.metadata.schema == null) {
      throw new Error("Loaded tile has no schema defined");
    }
    __privateGet(this, _model).tiles[tileID] = {
      alias,
      commits,
      schema: await this.loadSchema(stream.metadata.schema),
      version: stream.commitId.toString()
    };
    __privateGet(this, _aliases).tiles[alias] = tileID;
    return tileID;
  }
  async toPublished() {
    return await publishModel(__privateGet(this, _ceramic), __privateGet(this, _model));
  }
  toJSON() {
    return encodeModel(__privateGet(this, _model));
  }
};
let ModelManager = _ModelManager;
_aliases = new WeakMap();
_ceramic = new WeakMap();
_model = new WeakMap();
_referenced = new WeakMap();
_streams = new WeakMap();

function getName(base, prefix = "") {
  const withCase = changeCase.pascalCase(base);
  return withCase.startsWith(prefix) ? withCase : prefix + withCase;
}
function getItemField(model, schema, parent, owner) {
  const name = schema.title ?? "";
  if (schema.type === "array") {
    throw new Error("Unsupported item field of type array");
  }
  if (schema.type === "string") {
    const schemas = getReference(schema);
    if (schemas == null) {
      return { ...schema, type: "string" };
    }
    const refName = getName(name, parent);
    const ref = { schemas, owner };
    model.references[refName] = ref;
    return { type: "reference", ...ref };
  }
  if (schema.type === "object") {
    return { type: "object", name: addModelSchema(model, schema, { name, parent, owner }) };
  }
  return schema;
}
function addModelSchema(model, schema, options = {}) {
  const providedTitle = options.name ?? schema.title;
  if (providedTitle == null) {
    throw new Error("Schema must have a title");
  }
  const name = getName(providedTitle, options.parent);
  if (schema.type === "string") {
    const reference = getReference(schema);
    if (reference != null) {
      model.references[name] = { schemas: reference, owner: options.owner };
    }
  } else if (schema.type === "array" && schema.items != null) {
    model.lists[name] = getItemField(model, schema.items, name, options.owner);
  } else if (schema.type === "object" && schema.properties != null) {
    const requiredProps = schema.required ?? [];
    const fields = Object.entries(schema.properties).reduce((acc, [key, value]) => {
      const propName = value.title ?? key;
      const prop = changeCase.camelCase(key);
      const opts = { name: propName, parent: name, owner: options.owner ?? name };
      const required = requiredProps.includes(key);
      if (value.type === "string") {
        const reference = getReference(value);
        if (reference == null) {
          acc[prop] = { ...value, required, type: "string" };
        } else {
          const refName = getName(propName, name);
          const ref = { schemas: reference, owner: options.owner ?? name };
          model.references[refName] = ref;
          acc[prop] = { required, type: "reference", ...ref };
        }
      } else if (value.type === "array") {
        if (value.items == null) {
          throw new Error(`Missing items in field ${key}`);
        }
        acc[prop] = { required, type: "list", name: addModelSchema(model, value, opts) };
      } else if (value.type === "object") {
        acc[prop] = { required, type: "object", name: addModelSchema(model, value, opts) };
      } else {
        acc[prop] = { ...value, required };
      }
      return acc;
    }, {});
    model.objects[name] = { fields, parents: options.parent ? [options.parent] : null };
  }
  return name;
}
async function createGraphQLModel(manager) {
  const model = {
    collections: {},
    index: {},
    lists: {},
    objects: {},
    referenced: {},
    references: {},
    roots: {}
  };
  const handleSchemas = manager.schemas.map(async (name) => {
    const id = manager.getSchemaID(name);
    const stream = await manager.loadStream(id);
    const schema = stream.content;
    if (schema == null) {
      throw new Error(`Could not load schema ${name}`);
    }
    const schemaURL = stream.commitId.toUrl();
    if (schema.$comment?.startsWith(constants.CIP88_APPEND_COLLECTION_PREFIX)) {
      const sliceSchemaID = schema.$comment.substr(constants.CIP88_APPEND_COLLECTION_PREFIX.length);
      await manager.loadSchema(sliceSchemaID);
      const sliceSchemaDoc = await manager.loadStream(sliceSchemaID);
      const itemSchema = sliceSchemaDoc.content?.properties?.contents?.items?.oneOf?.[0];
      if (itemSchema == null) {
        throw new Error(`Could not extract item schema ${name}`);
      }
      model.collections[name] = {
        schema: schemaURL,
        item: getItemField(model, itemSchema, name, name)
      };
      model.referenced[schemaURL] = { type: "collection", name };
    } else {
      model.referenced[schemaURL] = {
        type: "object",
        name: addModelSchema(model, schema)
      };
    }
  });
  const handleDefinitions = manager.definitions.map(async (name) => {
    const id = manager.getDefinitionID(name);
    const stream = await manager.loadStream(id);
    const definition = stream.content;
    if (definition == null) {
      throw new Error(`Could not load definition ${name}`);
    }
    model.index[name] = { id: stream.id.toString(), schema: definition.schema };
  });
  const handleTiles = manager.tiles.map(async (name) => {
    const id = manager.getTileID(name);
    const stream = await manager.loadStream(id);
    const { schema } = stream.metadata;
    if (schema == null) {
      throw new Error(`Missing schema for tile ${name}`);
    }
    model.roots[name] = { id: stream.id.toString(), schema };
  });
  await Promise.all([...handleSchemas, ...handleDefinitions, ...handleTiles]);
  return model;
}

const validateSchemaSecure = new Ajv__default['default']({ strict: false }).compile(SecureSchema__default['default']);
function isSecureSchema(schema) {
  const ajv = new Ajv__default['default']();
  addFormats__default['default'](ajv);
  ajv.compile(schema);
  return validateSchemaSecure(schema);
}

exports.ModelManager = ModelManager;
exports.addModelSchema = addModelSchema;
exports.applyMap = applyMap;
exports.createGraphQLModel = createGraphQLModel;
exports.createModelDoc = createModelDoc;
exports.decodeDagJWS = decodeDagJWS;
exports.decodeDagJWSResult = decodeDagJWSResult;
exports.decodeEntryCommits = decodeEntryCommits;
exports.decodeModel = decodeModel;
exports.decodeSignedMap = decodeSignedMap;
exports.encodeDagJWS = encodeDagJWS;
exports.encodeDagJWSResult = encodeDagJWSResult;
exports.encodeEntryCommits = encodeEntryCommits;
exports.encodeModel = encodeModel;
exports.encodeSignedMap = encodeSignedMap;
exports.extractSchemaReferences = extractSchemaReferences;
exports.getItemField = getItemField;
exports.getReference = getReference;
exports.isSecureSchema = isSecureSchema;
exports.promiseMap = promiseMap;
exports.publishCommits = publishCommits;
exports.publishDataStoreSchemas = publishDataStoreSchemas;
exports.publishEncodedModel = publishEncodedModel;
exports.publishModel = publishModel;
exports.publishSignedMap = publishSignedMap;
exports.streamIDToString = streamIDToString;
exports.validateSchemaSecure = validateSchemaSecure;
//# sourceMappingURL=lib.cjs.map
