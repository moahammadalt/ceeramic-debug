{"version":3,"file":"lib.mjs","sources":["../src/utils.ts","../src/encoding.ts","../src/publishing.ts","../src/schema.ts","../src/datamodel.ts","../src/graphql.ts","../src/validation.ts"],"sourcesContent":["import type { StreamRef } from '@ceramicnetwork/streamid'\n\nexport function streamIDToString(id: StreamRef | string): string {\n  return typeof id === 'string' ? id : id.toString()\n}\n\n/** @internal */\nexport function applyMap<\n  M extends Record<string, unknown>,\n  V extends M[keyof M] = M[keyof M],\n  R = unknown\n>(inputs: M, callFunc: (input: V) => R): Record<keyof M, R> {\n  return Object.entries(inputs).reduce((acc, [key, value]) => {\n    acc[key as keyof M] = callFunc(value as V)\n    return acc\n  }, {} as Record<keyof M, R>)\n}\n\n/** @internal */\nexport async function promiseMap<\n  M extends Record<string, unknown>,\n  V extends M[keyof M] = M[keyof M],\n  R = unknown\n>(inputs: M, callFunc: (input: V) => Promise<R>): Promise<Record<keyof M, R>> {\n  const results = await Promise.all(Object.values(inputs).map((value) => callFunc(value as any)))\n  return Object.keys(inputs).reduce((acc, key, i) => {\n    acc[key as keyof M] = results[i]\n    return acc\n  }, {} as Record<keyof M, R>)\n}\n","import type { EncodedDagJWS, EncodedDagJWSResult, ManagedEntry, ManagedModel } from '@glazed/types'\nimport CID from 'cids'\nimport type { DagJWS, DagJWSResult } from 'dids'\nimport { fromString, toString } from 'uint8arrays'\n\nimport { applyMap } from './utils'\n\nexport function decodeDagJWS({ payload, signatures, link }: EncodedDagJWS): DagJWS {\n  return { payload, signatures, link: link ? new CID(link) : undefined }\n}\n\nexport function encodeDagJWS({ payload, signatures, link }: DagJWS): EncodedDagJWS {\n  return { payload, signatures, link: link?.toString() }\n}\n\nexport function decodeDagJWSResult({ jws, linkedBlock }: EncodedDagJWSResult): DagJWSResult {\n  return { jws: decodeDagJWS(jws), linkedBlock: fromString(linkedBlock, 'base64pad') }\n}\n\nexport function encodeDagJWSResult({ jws, linkedBlock }: DagJWSResult): EncodedDagJWSResult {\n  return { jws: encodeDagJWS(jws), linkedBlock: toString(linkedBlock, 'base64pad') }\n}\n\n/** @internal */\nexport function decodeSignedMap<K extends string>(\n  data: Record<K, Array<EncodedDagJWSResult>>\n): Record<K, Array<DagJWSResult>> {\n  return applyMap(data, (records) => records.map(decodeDagJWSResult))\n}\n\n/** @internal */\nexport function encodeSignedMap<K extends string>(\n  data: Record<K, Array<DagJWSResult>>\n): Record<K, Array<EncodedDagJWSResult>> {\n  return applyMap(data, (records) => records.map(encodeDagJWSResult))\n}\n\n/** @internal */\nexport function decodeEntryCommits(\n  entry: ManagedEntry<EncodedDagJWSResult>\n): ManagedEntry<DagJWSResult> {\n  return { ...entry, commits: entry.commits.map(decodeDagJWSResult) }\n}\n\nexport function decodeModel(model: ManagedModel<EncodedDagJWSResult>): ManagedModel<DagJWSResult> {\n  return {\n    schemas: applyMap(model.schemas, (schema) => {\n      return { ...schema, commits: schema.commits.map(decodeDagJWSResult) }\n    }),\n    definitions: applyMap(model.definitions, decodeEntryCommits),\n    tiles: applyMap(model.tiles, decodeEntryCommits),\n  }\n}\n\n/** @internal */\nexport function encodeEntryCommits(\n  entry: ManagedEntry<DagJWSResult>\n): ManagedEntry<EncodedDagJWSResult> {\n  return { ...entry, commits: entry.commits.map(encodeDagJWSResult) }\n}\n\nexport function encodeModel(model: ManagedModel<DagJWSResult>): ManagedModel<EncodedDagJWSResult> {\n  return {\n    schemas: applyMap(model.schemas, (schema) => {\n      return { ...schema, commits: schema.commits.map(encodeDagJWSResult) }\n    }),\n    definitions: applyMap(model.definitions, encodeEntryCommits),\n    tiles: applyMap(model.tiles, encodeEntryCommits),\n  }\n}\n","import type {\n  CeramicApi,\n  CeramicCommit,\n  GenesisCommit,\n  StreamMetadata,\n} from '@ceramicnetwork/common'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\n\nimport { promiseMap } from './utils'\n\nconst PUBLISH_OPTS = { anchor: false }\n\n/** @internal */\nexport async function createModelDoc<T = Record<string, any>>(\n  ceramic: CeramicApi,\n  content: T,\n  metadata: Partial<StreamMetadata> = {}\n): Promise<TileDocument<T>> {\n  const doc = await TileDocument.create<T>(ceramic, content, metadata, PUBLISH_OPTS)\n  await ceramic.pin.add(doc.id)\n  return doc\n}\n\n/** @internal */\nexport async function publishCommits(\n  ceramic: CeramicApi,\n  [genesis, ...updates]: Array<CeramicCommit>\n): Promise<TileDocument<Record<string, any>>> {\n  const doc = await TileDocument.createFromGenesis<TileDocument<Record<string, any>>>(\n    ceramic,\n    genesis as GenesisCommit,\n    PUBLISH_OPTS\n  )\n  await ceramic.pin.add(doc.id)\n  for (const commit of updates) {\n    await ceramic.applyCommit(doc.id, commit, PUBLISH_OPTS)\n  }\n  return doc\n}\n\n/** @internal */\nexport async function publishSignedMap<T extends string = string>(\n  ceramic: CeramicApi,\n  signed: Record<T, Array<CeramicCommit>>\n): Promise<Record<T, TileDocument>> {\n  return await promiseMap(signed, async (commits) => await publishCommits(ceramic, commits))\n}\n","import { CIP88_REF_PREFIX } from '@glazed/constants'\nimport type { Schema } from '@glazed/types'\n\n/** @internal */\nexport function getReference(schema: Schema): Array<string> | null {\n  if (schema.$comment?.startsWith(CIP88_REF_PREFIX)) {\n    const schemasString = schema.$comment.substr(CIP88_REF_PREFIX.length)\n    if (schemasString.length) {\n      const schemas = schemasString.split('|')\n      schemas.sort()\n      return schemas\n    }\n  }\n  return null\n}\n\n/**\n * Recursively extract references to other schemas from a JSON schema arrays and objects\n *\n * @internal */\nexport function extractSchemaReferences(schema: Schema, path = ''): Record<string, Array<string>> {\n  if (schema.type === 'string') {\n    const refs = getReference(schema)\n    return refs != null && refs.length > 0 ? { [path]: refs } : {}\n  }\n  if (schema.type === 'array') {\n    return extractSchemaReferences(schema.items, path)\n  }\n  if (schema.type === 'object' && schema.properties != null) {\n    // TODO: extract collection slice schema URL\n    return Object.entries(schema.properties as Record<string, Schema>).reduce(\n      (acc, [key, prop]) => {\n        const propPath = path === '' ? key : `${path}.${key}`\n        return Object.assign(acc, extractSchemaReferences(prop, propPath))\n      },\n      {} as Record<string, Array<string>>\n    )\n  }\n  return {}\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */\n\nimport type { CeramicApi, StreamMetadata } from '@ceramicnetwork/common'\nimport { CommitID, StreamID, StreamRef } from '@ceramicnetwork/streamid'\nimport { TileDocument } from '@ceramicnetwork/stream-tile'\nimport { CIP11_DEFINITION_SCHEMA_URL } from '@glazed/constants'\nimport type { Definition } from '@glazed/did-datastore-model'\nimport { model as encodedDataStoreModel } from '@glazed/did-datastore-model'\nimport type {\n  EncodedManagedModel,\n  ManagedEntry,\n  ManagedID,\n  ManagedModel,\n  ManagedSchema,\n  ModelData,\n  PublishedModel,\n  Schema,\n} from '@glazed/types'\nimport type { DagJWSResult } from 'dids'\n\nimport { decodeModel, encodeModel } from './encoding'\nimport { createModelDoc, publishCommits } from './publishing'\nimport { extractSchemaReferences } from './schema'\n\ntype ManagedReferenced = {\n  definitions: Set<ManagedID>\n  schemas: Set<ManagedID>\n  tiles: Set<ManagedID>\n}\n\ntype CreateContentType = {\n  definition: Definition\n  schema: Schema\n  tile: Record<string, unknown>\n}\n\ntype UsePublishedIDType = {\n  definition: StreamID | string\n  schema: StreamRef | string\n  tile: StreamID | string\n}\n\nfunction getManagedIDAndVersion(id: StreamRef | string): [ManagedID, string | null] {\n  const streamID = typeof id === 'string' ? StreamRef.from(id) : id\n  return [streamID.baseID.toString(), CommitID.isInstance(streamID) ? streamID.toString() : null]\n}\n\nfunction getManagedID(id: StreamRef | string): ManagedID {\n  const streamID = typeof id === 'string' ? StreamRef.from(id) : id\n  return streamID.baseID.toString()\n}\n\nfunction isSupportedDID(did: string): boolean {\n  return did.startsWith('did:key')\n}\n\nfunction docHasSupportedDID(doc: TileDocument<any>): boolean {\n  return isSupportedDID(doc.metadata.controllers[0])\n}\n\nconst dataStoreModel = decodeModel(encodedDataStoreModel)\nexport async function publishDataStoreSchemas(ceramic: CeramicApi): Promise<void> {\n  await Promise.all(\n    Object.values(dataStoreModel.schemas).map(async (schema) => {\n      return await publishCommits(ceramic, schema.commits)\n    })\n  )\n}\n\n// Publish a managed model to the given Ceramic node\nexport async function publishModel(\n  ceramic: CeramicApi,\n  model: ManagedModel\n): Promise<PublishedModel> {\n  const [schemas] = await Promise.all([\n    Promise.all(\n      Object.values(model.schemas).map(async (schema) => {\n        const stream = await publishCommits(ceramic, schema.commits)\n        return [schema.alias, stream.commitId.toUrl()]\n      })\n    ),\n    publishDataStoreSchemas(ceramic),\n  ])\n  const [definitions, tiles] = await Promise.all([\n    await Promise.all(\n      Object.values(model.definitions).map(async (entry) => {\n        const stream = await publishCommits(ceramic, entry.commits)\n        return [entry.alias, stream.id.toString()]\n      })\n    ),\n    await Promise.all(\n      Object.values(model.tiles).map(async (entry) => {\n        const stream = await publishCommits(ceramic, entry.commits)\n        return [entry.alias, stream.id.toString()]\n      })\n    ),\n  ])\n  return {\n    definitions: Object.fromEntries(definitions),\n    schemas: Object.fromEntries(schemas),\n    tiles: Object.fromEntries(tiles),\n  }\n}\n\n// Publish a JSON-encoded managed model to the given Ceramic node\nexport async function publishEncodedModel(\n  ceramic: CeramicApi,\n  model: EncodedManagedModel\n): Promise<PublishedModel> {\n  return await publishModel(ceramic, decodeModel(model))\n}\n\n/**\n * ```sh\n * import { ModelManager } from '@glazed/devtools'\n * ```\n */\nexport class ModelManager {\n  public static fromJSON(ceramic: CeramicApi, encoded: EncodedManagedModel): ModelManager {\n    return new ModelManager(ceramic, decodeModel(encoded))\n  }\n\n  #aliases: ModelData<string> = {\n    definitions: {},\n    schemas: {},\n    tiles: {},\n  }\n  #ceramic: CeramicApi\n  #model: ManagedModel = {\n    definitions: {},\n    schemas: {},\n    tiles: {},\n  }\n  #referenced: Record<ManagedID, ManagedReferenced> = {}\n  #streams: Record<ManagedID, Promise<TileDocument>> = {}\n\n  constructor(ceramic: CeramicApi, model?: ManagedModel) {\n    this.#ceramic = ceramic\n    if (model != null) {\n      this.addModel(model)\n    }\n  }\n\n  // Getters\n\n  get model(): ManagedModel {\n    return this.#model\n  }\n\n  get schemas(): Array<string> {\n    return Object.keys(this.#aliases.schemas).sort()\n  }\n\n  get definitions(): Array<string> {\n    return Object.keys(this.#aliases.definitions).sort()\n  }\n\n  get tiles(): Array<string> {\n    return Object.keys(this.#aliases.tiles).sort()\n  }\n\n  // Imports\n\n  addModel(model: ManagedModel): void {\n    Object.assign(this.#model.definitions, model.definitions)\n    Object.assign(this.#model.schemas, model.schemas)\n    Object.assign(this.#model.tiles, model.tiles)\n\n    for (const [id, schema] of Object.entries(model.schemas)) {\n      this.#aliases.schemas[schema.alias] = id\n      for (const refIDs of Object.values(schema.dependencies)) {\n        for (const refID of refIDs) {\n          if (this.#referenced[refID] == null) {\n            this.#referenced[refID] = {\n              definitions: new Set<ManagedID>(),\n              schemas: new Set<ManagedID>(),\n              tiles: new Set<ManagedID>(),\n            }\n          }\n          this.#referenced[refID].schemas.add(id)\n        }\n      }\n    }\n    for (const [id, definition] of Object.entries(model.definitions)) {\n      this.#aliases.definitions[definition.alias] = id\n      if (this.#referenced[definition.schema] == null) {\n        this.#referenced[definition.schema] = {\n          definitions: new Set<ManagedID>(),\n          schemas: new Set<ManagedID>(),\n          tiles: new Set<ManagedID>(),\n        }\n      }\n      this.#referenced[definition.schema].definitions.add(id)\n    }\n    for (const [id, tile] of Object.entries(model.tiles)) {\n      this.#aliases.tiles[tile.alias] = id\n      if (this.#referenced[tile.schema] == null) {\n        this.#referenced[tile.schema] = {\n          definitions: new Set<ManagedID>(),\n          schemas: new Set<ManagedID>(),\n          tiles: new Set<ManagedID>(),\n        }\n      }\n      this.#referenced[tile.schema].tiles.add(id)\n    }\n  }\n\n  addJSONModel(encoded: EncodedManagedModel): void {\n    this.addModel(decodeModel(encoded))\n  }\n\n  // Loaders\n\n  async loadStream(streamID: StreamRef | string): Promise<TileDocument> {\n    const id = typeof streamID === 'string' ? streamID : streamID.baseID.toString()\n    if (this.#streams[id] == null) {\n      this.#streams[id] = this._loadAndValidateStream(id)\n    }\n    return await this.#streams[id]\n  }\n\n  /** @internal */\n  async _loadAndValidateStream(id: string): Promise<TileDocument> {\n    const stream = await TileDocument.load<Record<string, any>>(this.#ceramic, id)\n    if (stream.anchorCommitIds.length !== 0) {\n      throw new Error(`Invalid stream ${id}: contains anchor commit`)\n    }\n\n    // Shortcut logic for single commit\n    if (stream.allCommitIds.length === 1 && docHasSupportedDID(stream)) {\n      return stream\n    }\n\n    const commits = await Promise.all(\n      stream.allCommitIds.map(async (commitID) => {\n        return await TileDocument.load(this.#ceramic, commitID)\n      })\n    )\n    const unsupported = commits.find((commit) => !docHasSupportedDID(commit))\n    if (unsupported != null) {\n      throw new Error(`Invalid stream ${id}: contains a commit authored by an unsupported DID`)\n    }\n\n    return stream\n  }\n\n  async loadCommits(id: ManagedID): Promise<Array<DagJWSResult>> {\n    const commits = await this.#ceramic.loadStreamCommits(id)\n    return commits.map((r) => r.value as DagJWSResult)\n  }\n\n  async loadSchema(id: StreamRef | string, alias?: string): Promise<ManagedID> {\n    const [managedID, commitID] = getManagedIDAndVersion(id)\n    if (commitID === null) {\n      throw new Error(`Expected CommitID to load schema: ${managedID}`)\n    }\n\n    const existing = this.#model.schemas[managedID]\n    if (existing != null) {\n      if (existing.version !== commitID) {\n        throw new Error(`Another version for this schema is already set: ${existing.version}`)\n      }\n      if (alias != null && existing.alias !== alias) {\n        throw new Error(`Another alias for this schema is already set: ${existing.alias}`)\n      }\n      return managedID\n    }\n\n    const [stream, commits] = await Promise.all([\n      this.loadStream(commitID),\n      this.loadCommits(managedID),\n    ])\n    const content = (stream.content ?? {}) as Schema\n    const name = alias ?? content.title\n    if (name == null) {\n      throw new Error('Schema must have a title property or an alias must be provided')\n    }\n\n    const dependencies = await this.loadSchemaDependencies(content)\n    this.#model.schemas[managedID] = { alias: name, commits, dependencies, version: commitID }\n    this.#aliases.schemas[name] = managedID\n\n    return managedID\n  }\n\n  async loadSchemaDependencies(schema: Schema): Promise<Record<string, Array<string>>> {\n    const references = extractSchemaReferences(schema)\n\n    const ids = new Set<string>()\n    for (const refs of Object.values(references)) {\n      for (const ref of refs) {\n        ids.add(ref)\n      }\n    }\n    const loaded = await Promise.all(\n      Array.from(ids).map(async (id) => [id, await this.loadSchema(id)])\n    )\n    const idToManaged: Record<string, string> = Object.fromEntries(loaded)\n\n    return Object.entries(references).reduce((acc, [path, deps]) => {\n      acc[path] = deps.map((id) => idToManaged[id])\n      return acc\n    }, {} as Record<string, Array<string>>)\n  }\n\n  // High-level\n\n  async create<T extends keyof CreateContentType, Content = CreateContentType[T]>(\n    type: T,\n    alias: string,\n    content: Content,\n    meta?: Partial<StreamMetadata>\n  ): Promise<ManagedID> {\n    switch (type) {\n      case 'schema':\n        return await this.createSchema(alias, content as any)\n      case 'definition':\n        return await this.createDefinition(alias, content as any)\n      case 'tile':\n        return await this.createTile(alias, content as any, meta)\n      default:\n        throw new Error(`Unsupported type: ${type as string}`)\n    }\n  }\n\n  async usePublished<T extends keyof UsePublishedIDType, ID = UsePublishedIDType[T]>(\n    type: T,\n    alias: string,\n    id: ID\n  ): Promise<ManagedID> {\n    switch (type) {\n      case 'schema':\n        return await this.usePublishedSchema(alias, id as any)\n      case 'definition':\n        return await this.usePublishedDefinition(alias, id as any)\n      case 'tile':\n        return await this.usePublishedTile(alias, id as any)\n      default:\n        throw new Error(`Unsupported type: ${type as string}`)\n    }\n  }\n\n  // Schemas\n\n  getSchemaID(alias: string): ManagedID | null {\n    return this.#aliases.schemas[alias] ?? null\n  }\n\n  hasSchemaAlias(alias: string): boolean {\n    return this.getSchemaID(alias) != null\n  }\n\n  getSchema(id: ManagedID): ManagedSchema | null {\n    return this.#model.schemas[id] ?? null\n  }\n\n  getSchemaURL(id: ManagedID): string | null {\n    const schema = this.#model.schemas[id]\n    return schema ? CommitID.fromString(schema.version).toUrl() : null\n  }\n\n  getSchemaByAlias(alias: string): ManagedSchema | null {\n    const id = this.getSchemaID(alias)\n    return id ? this.getSchema(id) : null\n  }\n\n  async createSchema(alias: string, schema: Schema): Promise<ManagedID> {\n    if (this.#ceramic.did == null || !this.#ceramic.did.authenticated) {\n      throw new Error('Ceramic instance must be authenticated')\n    }\n    if (!isSupportedDID(this.#ceramic.did.id)) {\n      throw new Error(\n        `Invalid DID ${\n          this.#ceramic.did.id\n        } to create stream for model, only \"did:key\" is supported`\n      )\n    }\n    if (this.hasSchemaAlias(alias)) {\n      throw new Error(`Schema ${alias} already exists`)\n    }\n\n    const [stream, dependencies] = await Promise.all([\n      createModelDoc(this.#ceramic, schema),\n      this.loadSchemaDependencies(schema),\n    ])\n\n    const id = stream.id.toString()\n    this.#model.schemas[id] = {\n      alias,\n      commits: await this.loadCommits(id),\n      dependencies,\n      version: stream.commitId.toString(),\n    }\n    this.#aliases.schemas[alias] = id\n\n    return id\n  }\n\n  async usePublishedSchema(alias: string, id: StreamRef | string): Promise<ManagedID> {\n    if (alias == null) {\n      throw new Error('Schema alias must be provided')\n    }\n    return await this.loadSchema(id, alias)\n  }\n\n  // Definitions\n\n  getDefinitionID(alias: string): ManagedID | null {\n    return this.#aliases.definitions[alias] ?? null\n  }\n\n  hasDefinitionAlias(alias: string): boolean {\n    return this.getDefinitionID(alias) != null\n  }\n\n  getDefinition(id: ManagedID): ManagedEntry | null {\n    return this.#model.definitions[id] ?? null\n  }\n\n  async createDefinition(alias: string, definition: Definition): Promise<ManagedID> {\n    if (this.#ceramic.did == null || !this.#ceramic.did.authenticated) {\n      throw new Error('Ceramic instance must be authenticated')\n    }\n    if (!isSupportedDID(this.#ceramic.did.id)) {\n      throw new Error(\n        `Invalid DID ${\n          this.#ceramic.did.id\n        } to create stream for model, only \"did:key\" is supported`\n      )\n    }\n    if (this.hasDefinitionAlias(alias)) {\n      throw new Error(`Definition ${alias} already exists`)\n    }\n\n    await publishDataStoreSchemas(this.#ceramic)\n    const [stream, schemaID] = await Promise.all([\n      createModelDoc(this.#ceramic, definition, { schema: CIP11_DEFINITION_SCHEMA_URL }),\n      this.loadSchema(definition.schema),\n    ])\n\n    const id = stream.id.toString()\n    this.#model.definitions[id] = {\n      alias,\n      commits: await this.loadCommits(id),\n      schema: schemaID,\n      version: stream.commitId.toString(),\n    }\n    this.#aliases.definitions[alias] = id\n\n    return id\n  }\n\n  async usePublishedDefinition(alias: string, id: StreamID | string): Promise<ManagedID> {\n    if (this.hasDefinitionAlias(alias)) {\n      throw new Error(`Definition ${alias} already exists`)\n    }\n\n    const definitionID = getManagedID(id)\n    const [stream, commits] = await Promise.all([\n      this.loadStream(id),\n      this.loadCommits(definitionID),\n    ])\n\n    this.#model.definitions[definitionID] = {\n      alias,\n      commits,\n      schema: await this.loadSchema((stream.content as Definition).schema),\n      version: stream.commitId.toString(),\n    }\n    this.#aliases.definitions[alias] = definitionID\n\n    return definitionID\n  }\n\n  // Tiles\n\n  getTileID(alias: string): ManagedID | null {\n    return this.#aliases.tiles[alias] ?? null\n  }\n\n  hasTileAlias(alias: string): boolean {\n    return this.getTileID(alias) != null\n  }\n\n  getTile(id: ManagedID): ManagedEntry | null {\n    return this.#model.tiles[id] ?? null\n  }\n\n  async createTile<T extends Record<string, unknown>>(\n    alias: string,\n    contents: T,\n    meta: Partial<StreamMetadata> = {}\n  ): Promise<ManagedID> {\n    if (this.#ceramic.did == null || !this.#ceramic.did.authenticated) {\n      throw new Error('Ceramic instance must be authenticated')\n    }\n    if (!isSupportedDID(this.#ceramic.did.id)) {\n      throw new Error('Unsupported DID to create stream for model')\n    }\n    if (this.hasTileAlias(alias)) {\n      throw new Error(`Tile ${alias} already exists`)\n    }\n    if (meta.schema == null) {\n      throw new Error(`Missing schema to create tile ${alias}`)\n    }\n\n    const [stream, schemaID] = await Promise.all([\n      createModelDoc(this.#ceramic, contents, meta),\n      this.loadSchema(meta.schema),\n    ])\n\n    const id = stream.id.toString()\n    this.#model.tiles[id] = {\n      alias,\n      commits: await this.loadCommits(id),\n      schema: schemaID,\n      version: stream.commitId.toString(),\n    }\n    this.#aliases.tiles[alias] = id\n\n    return id\n  }\n\n  async usePublishedTile(alias: string, id: StreamID | string): Promise<ManagedID> {\n    if (this.hasTileAlias(alias)) {\n      throw new Error(`Tile ${alias} already exists`)\n    }\n\n    const tileID = getManagedID(id)\n    const [stream, commits] = await Promise.all([this.loadStream(id), this.loadCommits(tileID)])\n    if (stream.metadata.schema == null) {\n      throw new Error('Loaded tile has no schema defined')\n    }\n\n    this.#model.tiles[tileID] = {\n      alias,\n      commits,\n      schema: await this.loadSchema(stream.metadata.schema),\n      version: stream.commitId.toString(),\n    }\n    this.#aliases.tiles[alias] = tileID\n\n    return tileID\n  }\n\n  // Exports\n\n  async toPublished(): Promise<PublishedModel> {\n    return await publishModel(this.#ceramic, this.#model)\n  }\n\n  toJSON(): EncodedManagedModel {\n    return encodeModel(this.#model)\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */\n\nimport { CIP88_APPEND_COLLECTION_PREFIX } from '@glazed/constants'\nimport type { Definition } from '@glazed/did-datastore-model'\nimport type { GraphQLModel, ItemField, ObjectField } from '@glazed/graphql-types'\nimport type { Schema } from '@glazed/types'\nimport { camelCase, pascalCase } from 'change-case'\n\nimport type { ModelManager } from './datamodel'\nimport { getReference } from './schema'\n\n/** @internal */\nfunction getName(base: string, prefix = ''): string {\n  const withCase = pascalCase(base)\n  return withCase.startsWith(prefix) ? withCase : prefix + withCase\n}\n\n/** @internal */\nexport function getItemField(\n  model: GraphQLModel,\n  schema: Schema,\n  parent: string,\n  owner: string\n): ItemField {\n  const name = schema.title ?? ''\n  if (schema.type === 'array') {\n    throw new Error('Unsupported item field of type array')\n  }\n  if (schema.type === 'string') {\n    const schemas = getReference(schema)\n    if (schemas == null) {\n      return { ...schema, type: 'string' }\n    }\n\n    const refName = getName(name, parent)\n    const ref = { schemas, owner }\n    model.references[refName] = ref\n    return { type: 'reference', ...ref }\n  }\n  if (schema.type === 'object') {\n    return { type: 'object', name: addModelSchema(model, schema, { name, parent, owner }) }\n  }\n  return schema as ItemField\n}\n\nexport type AddModelSchemaOptions = {\n  name?: string\n  parent?: string\n  owner?: string\n}\n\n/**\n * Add a JSON schema to the provided records based on its type\n *\n * @internal\n * */\nexport function addModelSchema(\n  model: GraphQLModel,\n  schema: Schema,\n  options: AddModelSchemaOptions = {}\n): string {\n  const providedTitle = options.name ?? schema.title\n  if (providedTitle == null) {\n    throw new Error('Schema must have a title')\n  }\n\n  // TODO: add parents?: Array<string> to options\n  // If no parent and type object, treat as node and use canonical name\n  // Make sure object doesn't already exist in model, if so just add extra parents\n  const name = getName(providedTitle, options.parent)\n\n  if (schema.type === 'string') {\n    const reference = getReference(schema)\n    if (reference != null) {\n      model.references[name] = { schemas: reference, owner: options.owner as string }\n    }\n  } else if (schema.type === 'array' && schema.items != null) {\n    model.lists[name] = getItemField(model, schema.items, name, options.owner as string)\n  } else if (schema.type === 'object' && schema.properties != null) {\n    const requiredProps = (schema.required as Array<string>) ?? []\n    const fields = Object.entries(schema.properties as Record<string, any>).reduce(\n      (acc, [key, value]: [string, Schema]) => {\n        const propName = (value.title as string) ?? key\n        const prop = camelCase(key)\n        const opts = { name: propName, parent: name, owner: options.owner ?? name }\n        const required = requiredProps.includes(key)\n        if (value.type === 'string') {\n          const reference = getReference(value)\n          if (reference == null) {\n            acc[prop] = { ...value, required, type: 'string' }\n          } else {\n            const refName = getName(propName, name)\n            const ref = { schemas: reference, owner: options.owner ?? name }\n            model.references[refName] = ref\n            acc[prop] = { required, type: 'reference', ...ref }\n          }\n        } else if (value.type === 'array') {\n          if (value.items == null) {\n            throw new Error(`Missing items in field ${key}`)\n          }\n          acc[prop] = { required, type: 'list', name: addModelSchema(model, value, opts) }\n        } else if (value.type === 'object') {\n          acc[prop] = { required, type: 'object', name: addModelSchema(model, value, opts) }\n        } else {\n          acc[prop] = { ...value, required } as ObjectField\n        }\n        return acc\n      },\n      {} as Record<string, ObjectField>\n    )\n    model.objects[name] = { fields, parents: options.parent ? [options.parent] : null }\n  }\n\n  return name\n}\n\nexport async function createGraphQLModel(manager: ModelManager): Promise<GraphQLModel> {\n  // TODO: throw error on using reserved names:\n  // - \"node\" and \"index\" roots\n  // - \"id\" field in object if node\n\n  const model: GraphQLModel = {\n    collections: {},\n    index: {},\n    lists: {},\n    objects: {},\n    referenced: {},\n    references: {},\n    roots: {},\n  }\n\n  const handleSchemas = manager.schemas.map(async (name) => {\n    const id = manager.getSchemaID(name) as string\n    const stream = await manager.loadStream(id)\n    const schema = stream.content as Schema\n    if (schema == null) {\n      throw new Error(`Could not load schema ${name}`)\n    }\n\n    const schemaURL = stream.commitId.toUrl()\n    if (schema.$comment?.startsWith(CIP88_APPEND_COLLECTION_PREFIX)) {\n      const sliceSchemaID = schema.$comment.substr(CIP88_APPEND_COLLECTION_PREFIX.length)\n      await manager.loadSchema(sliceSchemaID)\n      const sliceSchemaDoc = await manager.loadStream(sliceSchemaID)\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n      const itemSchema = sliceSchemaDoc.content?.properties?.contents?.items?.oneOf?.[0]\n      if (itemSchema == null) {\n        throw new Error(`Could not extract item schema ${name}`)\n      }\n      model.collections[name] = {\n        schema: schemaURL,\n        item: getItemField(model, itemSchema, name, name),\n      }\n      model.referenced[schemaURL] = { type: 'collection', name }\n    } else {\n      model.referenced[schemaURL] = {\n        type: 'object',\n        name: addModelSchema(model, schema),\n      }\n    }\n  })\n\n  const handleDefinitions = manager.definitions.map(async (name) => {\n    const id = manager.getDefinitionID(name) as string\n    const stream = await manager.loadStream(id)\n    const definition = stream.content as Definition\n    if (definition == null) {\n      throw new Error(`Could not load definition ${name}`)\n    }\n    model.index[name] = { id: stream.id.toString(), schema: definition.schema }\n  })\n\n  const handleTiles = manager.tiles.map(async (name) => {\n    const id = manager.getTileID(name) as string\n    const stream = await manager.loadStream(id)\n    const { schema } = stream.metadata\n    if (schema == null) {\n      throw new Error(`Missing schema for tile ${name}`)\n    }\n    model.roots[name] = { id: stream.id.toString(), schema }\n  })\n\n  await Promise.all([...handleSchemas, ...handleDefinitions, ...handleTiles])\n\n  return model\n}\n","import Ajv from 'ajv'\nimport type { JSONSchemaType } from 'ajv'\nimport addFormats from 'ajv-formats'\nimport SecureSchema from 'ajv/lib/refs/json-schema-secure.json'\n\n/**\n * Seems the secure schema is not strict, this causes warnings to be logged\n *\n * @internal */\nexport const validateSchemaSecure = new Ajv({ strict: false }).compile(SecureSchema)\n\nexport function isSecureSchema<T = Record<string, any>>(schema: JSONSchemaType<T>): boolean {\n  const ajv = new Ajv()\n  addFormats(ajv)\n  ajv.compile(schema)\n  return validateSchemaSecure(schema)\n}\n"],"names":["encodedDataStoreModel"],"mappings":"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"}