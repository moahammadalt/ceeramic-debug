import type { CeramicApi, StreamMetadata } from '@ceramicnetwork/common';
import { StreamID, StreamRef } from '@ceramicnetwork/streamid';
import { TileDocument } from '@ceramicnetwork/stream-tile';
import type { Definition } from '@glazed/did-datastore-model';
import type { EncodedManagedModel, ManagedEntry, ManagedID, ManagedModel, ManagedSchema, PublishedModel, Schema } from '@glazed/types';
import type { DagJWSResult } from 'dids';
declare type CreateContentType = {
    definition: Definition;
    schema: Schema;
    tile: Record<string, unknown>;
};
declare type UsePublishedIDType = {
    definition: StreamID | string;
    schema: StreamRef | string;
    tile: StreamID | string;
};
export declare function publishDataStoreSchemas(ceramic: CeramicApi): Promise<void>;
export declare function publishModel(ceramic: CeramicApi, model: ManagedModel): Promise<PublishedModel>;
export declare function publishEncodedModel(ceramic: CeramicApi, model: EncodedManagedModel): Promise<PublishedModel>;
/**
 * ```sh
 * import { ModelManager } from '@glazed/devtools'
 * ```
 */
export declare class ModelManager {
    #private;
    static fromJSON(ceramic: CeramicApi, encoded: EncodedManagedModel): ModelManager;
    constructor(ceramic: CeramicApi, model?: ManagedModel);
    get model(): ManagedModel;
    get schemas(): Array<string>;
    get definitions(): Array<string>;
    get tiles(): Array<string>;
    addModel(model: ManagedModel): void;
    addJSONModel(encoded: EncodedManagedModel): void;
    loadStream(streamID: StreamRef | string): Promise<TileDocument>;
    /** @internal */
    _loadAndValidateStream(id: string): Promise<TileDocument>;
    loadCommits(id: ManagedID): Promise<Array<DagJWSResult>>;
    loadSchema(id: StreamRef | string, alias?: string): Promise<ManagedID>;
    loadSchemaDependencies(schema: Schema): Promise<Record<string, Array<string>>>;
    create<T extends keyof CreateContentType, Content = CreateContentType[T]>(type: T, alias: string, content: Content, meta?: Partial<StreamMetadata>): Promise<ManagedID>;
    usePublished<T extends keyof UsePublishedIDType, ID = UsePublishedIDType[T]>(type: T, alias: string, id: ID): Promise<ManagedID>;
    getSchemaID(alias: string): ManagedID | null;
    hasSchemaAlias(alias: string): boolean;
    getSchema(id: ManagedID): ManagedSchema | null;
    getSchemaURL(id: ManagedID): string | null;
    getSchemaByAlias(alias: string): ManagedSchema | null;
    createSchema(alias: string, schema: Schema): Promise<ManagedID>;
    usePublishedSchema(alias: string, id: StreamRef | string): Promise<ManagedID>;
    getDefinitionID(alias: string): ManagedID | null;
    hasDefinitionAlias(alias: string): boolean;
    getDefinition(id: ManagedID): ManagedEntry | null;
    createDefinition(alias: string, definition: Definition): Promise<ManagedID>;
    usePublishedDefinition(alias: string, id: StreamID | string): Promise<ManagedID>;
    getTileID(alias: string): ManagedID | null;
    hasTileAlias(alias: string): boolean;
    getTile(id: ManagedID): ManagedEntry | null;
    createTile<T extends Record<string, unknown>>(alias: string, contents: T, meta?: Partial<StreamMetadata>): Promise<ManagedID>;
    usePublishedTile(alias: string, id: StreamID | string): Promise<ManagedID>;
    toPublished(): Promise<PublishedModel>;
    toJSON(): EncodedManagedModel;
}
export {};
